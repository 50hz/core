<!DOCTYPE html><html><head>
  



  
  
  
  
  <script src="../polymer-gestures/src/scope.js"></script>
<script src="../polymer-gestures/src/targetfind.js"></script>
<script src="../polymer-gestures/src/touch-action.js"></script>
<script src="../polymer-gestures/src/eventFactory.js"></script>
<script src="../polymer-gestures/src/pointermap.js"></script>
<script src="../polymer-gestures/src/dispatcher.js"></script>
<script src="../polymer-gestures/src/mouse.js"></script>
<script src="../polymer-gestures/src/touch.js"></script>
<script src="../polymer-gestures/src/ms.js"></script>
<script src="../polymer-gestures/src/pointer.js"></script>
<script src="../polymer-gestures/src/platform-events.js"></script>
<script src="../polymer-gestures/src/track.js"></script>
<script src="../polymer-gestures/src/hold.js"></script>
<script src="../polymer-gestures/src/tap.js"></script>

<script src="../polymer-expressions/third_party/esprima/esprima.js"></script>
<script src="../polymer-expressions/src/polymer-expressions.js"></script>

<style shim-shadowdom="">
/*******************************
          Flex Layout
*******************************/

html /deep/ [layout][horizontal], html /deep/ [layout][vertical] {
  display: -ms-flexbox;
  display: -webkit-flex;
  display: flex;
}

html /deep/ [layout][horizontal][inline], html /deep/ [layout][vertical][inline] {
  display: -ms-inline-flexbox;
  display: -webkit-inline-flex;
  display: inline-flex;
}

html /deep/ [layout][horizontal] {
  -ms-flex-direction: row;
  -webkit-flex-direction: row;
  flex-direction: row;
}

html /deep/ [layout][horizontal][reverse] {
  -ms-flex-direction: row-reverse;
  -webkit-flex-direction: row-reverse;
  flex-direction: row-reverse;
}

html /deep/ [layout][vertical] {
  -ms-flex-direction: column;
  -webkit-flex-direction: column;
  flex-direction: column;
}

html /deep/ [layout][vertical][reverse] {
  -ms-flex-direction: column-reverse;
  -webkit-flex-direction: column-reverse;
  flex-direction: column-reverse;
}

html /deep/ [layout][wrap] {
  -ms-flex-wrap: wrap;
  -webkit-flex-wrap: wrap;
  flex-wrap: wrap;
}

html /deep/ [layout][wrap-reverse] {
  -ms-flex-wrap: wrap-reverse;
  -webkit-flex-wrap: wrap-reverse;
  flex-wrap: wrap-reverse;
}

html /deep/ [flex] {
  -ms-flex: 1 1 0.000000001px;
  -webkit-flex: 1;
  flex: 1;
  -webkit-flex-basis: 0.000000001px;
  flex-basis: 0.000000001px;
}

html /deep/ [vertical][layout] > [flex][auto-vertical], html /deep/ [vertical][layout]::shadow [flex][auto-vertical] {
  -ms-flex: 1 1 auto;
  -webkit-flex-basis: auto;
  flex-basis: auto;
}

html /deep/ [flex][auto] {
  -ms-flex: 1 1 auto;
  -webkit-flex-basis: auto;
  flex-basis: auto;
}

html /deep/ [flex][none] {
  -ms-flex: none;
  -webkit-flex: none;
  flex: none;
}

html /deep/ [flex][one] {
  -ms-flex: 1;
  -webkit-flex: 1;
  flex: 1;
}

html /deep/ [flex][two] {
  -ms-flex: 2;
  -webkit-flex: 2;
  flex: 2;
}

html /deep/ [flex][three] {
  -ms-flex: 3;
  -webkit-flex: 3;
  flex: 3;
}

html /deep/ [flex][four] {
  -ms-flex: 4;
  -webkit-flex: 4;
  flex: 4;
}

html /deep/ [flex][five] {
  -ms-flex: 5;
  -webkit-flex: 5;
  flex: 5;
}

html /deep/ [flex][six] {
  -ms-flex: 6;
  -webkit-flex: 6;
  flex: 6;
}

html /deep/ [flex][seven] {
  -ms-flex: 7;
  -webkit-flex: 7;
  flex: 7;
}

html /deep/ [flex][eight] {
  -ms-flex: 8;
  -webkit-flex: 8;
  flex: 8;
}

html /deep/ [flex][nine] {
  -ms-flex: 9;
  -webkit-flex: 9;
  flex: 9;
}

html /deep/ [flex][ten] {
  -ms-flex: 10;
  -webkit-flex: 10;
  flex: 10;
}

html /deep/ [flex][eleven] {
  -ms-flex: 11;
  -webkit-flex: 11;
  flex: 11;
}

html /deep/ [flex][twelve] {
  -ms-flex: 12;
  -webkit-flex: 12;
  flex: 12;
}

/* alignment in cross axis */

html /deep/ [layout][start] {
  -ms-flex-align: start;
  -webkit-align-items: flex-start;
  align-items: flex-start;
}

html /deep/ [layout][center], html /deep/ [layout][center-center] {
  -ms-flex-align: center;
  -webkit-align-items: center;
  align-items: center;
}

html /deep/ [layout][end] {
  -ms-flex-align: end;
  -webkit-align-items: flex-end;
  align-items: flex-end;
}

/* alignment in main axis */

html /deep/ [layout][start-justified] {
  -ms-flex-pack: start;
  -webkit-justify-content: flex-start;
  justify-content: flex-start;
}

html /deep/ [layout][center-justified], html /deep/ [layout][center-center] {
  -ms-flex-pack: center;
  -webkit-justify-content: center;
  justify-content: center;
}

html /deep/ [layout][end-justified] {
  -ms-flex-pack: end;
  -webkit-justify-content: flex-end;
  justify-content: flex-end;
}

html /deep/ [layout][around-justified] {
  -ms-flex-pack: distribute;
  -webkit-justify-content: space-around;
  justify-content: space-around;
}

html /deep/ [layout][justified] {
  -ms-flex-pack: justify;
  -webkit-justify-content: space-between;
  justify-content: space-between;
}

/* self alignment */

html /deep/ [self-start] {
  -ms-align-self: flex-start;
  -webkit-align-self: flex-start;
  align-self: flex-start;
}

html /deep/ [self-center] {
  -ms-align-self: center;
  -webkit-align-self: center;
  align-self: center;
}

html /deep/ [self-end] {
  -ms-align-self: flex-end;
  -webkit-align-self: flex-end;
  align-self: flex-end;
}

html /deep/ [self-stretch] {
  -ms-align-self: stretch;
  -webkit-align-self: stretch;
  align-self: stretch;
}

/*******************************
          Other Layout
*******************************/

html /deep/ [block] {
  display: block;
}

/* ie support for hidden */
html /deep/ [hidden] {
  display: none !important;
}

html /deep/ [relative] {
  position: relative;
}

html /deep/ [fit] {
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
}

body[fullbleed] {
  margin: 0;
  height: 100vh;
}

/*******************************
            Other
*******************************/

html /deep/ [segment], html /deep/ segment {
  display: block;
  position: relative;
  -webkit-box-sizing: border-box;
  -ms-box-sizing: border-box;
  box-sizing: border-box;
  margin: 1em 0.5em;
  padding: 1em;
  background-color: white;
  -webkit-box-shadow: 0px 0px 0px 1px rgba(0, 0, 0, 0.1);
  box-shadow: 0px 0px 0px 1px rgba(0, 0, 0, 0.1);
  border-radius: 5px 5px 5px 5px;
}

</style>
<script src="../polymer/src/polymer.js"></script>
<script src="../polymer/src/boot.js"></script>
<script src="../polymer/src/system/module.js"></script>

<!-- Do not load in the presence of webcomponents.js  -->


<style type="text/css">:host {
  display: block;
  position: relative;
}</style>
































</head>
<body><div hidden=""><polymer-element name="fin-hypergrid-constants" assetpath="">
  <template></template>
  <script>

'use strict';

(function() {

    var values = {
        defaultFont: '13px Tahoma, Geneva, sans-serif',
        foregroundColor: '#010126',
        backgroundColor: '#FFFFFF',
        foregroundSelColor: '#010126',
        backgroundSelColor: '#B7DBFF',
        fixedColBGColor: '#DFE3E8',
        fixedRowBGColor: '#DFE3E8',
        fixedColFGSelColor: '#010126',
        fixedRowFGSelColor: '#010126',
        fixedColBGSelColor: '#FFDC61',
        fixedRowBGSelColor: '#FFDC61',
        lineColor: '#C7C7C7',
        fixedRowAlign: 'center',
        fixedColAlign: 'center',
        cellPadding: 5,
        rowHeight: 20,
        colWidth: 100,
        topLeftHeaderBGColor: '#DFE3E8',
        repaintIntervalRate: 15
    };

    Polymer('fin-hypergrid-constants',{ /* jshint ignore:line */
        values: values
    });

})(); /* jshint ignore:line */

  </script>
</polymer-element>

<polymer-element name="fin-hypergrid-cell-provider" assetpath="">
  <template></template>
  <script>

'use strict';

(function() {

    //global variable for all instances to share, initialized by the first instances' ready call
    var constants;

    //DefaultCellProvider is the cache for cell renderers.  A CellRenderer is an object with a single function 'paint'.
    //There should only be a single reused CellRenderer object created for each type of CellRenderer.

    //Custom CellRenderers can be attached to myCellProvider.cellCache and then referenced through the getCell function that is overridden in your implementation.  Make sure to attach the config argument to the cell renderer that is returne

    //override [createCellProvider](DefaultGridBehavior.html) creating an instance of thisobject.  Override members of this object per your specific needs.
    //see [QGridBehavior.createCellProvider](QGridBehavior.html) for an example of overriding createCellProvider.

        //emersons utility function for rendering a rounded corner rectangle
        //<br>TODO:this should be moved to a graphics rendering lib
    var roundRect = function(ctx, x, y, width, height, radius, fill, stroke) {
        if (!stroke) {
            stroke = true;
        }
        if (!radius) {
            radius = 5;
        }
        ctx.beginPath();
        ctx.moveTo(x + radius, y);
        ctx.lineTo(x + width - radius, y);
        ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
        ctx.lineTo(x + width, y + height - radius);
        ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
        ctx.lineTo(x + radius, y + height);
        ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
        ctx.lineTo(x, y + radius);
        ctx.quadraticCurveTo(x, y, x + radius, y);
        ctx.closePath();
        if (stroke) {
            ctx.stroke();
        }
        if (fill) {
            ctx.fill();
        }
    };


    Polymer('fin-hypergrid-cell-provider',{ /* jslint ignore:line */
        created: function() {
            if (!constants) {
                constants = document.createElement('fin-hypergrid-constants').values;
            }
            this.cellCache = {};
            this.initializeCells();
        },

        //replace this function in on your instance of cellProvider
        getCell: function(config) {
            var cell = this.cellCache.simpleCellRenderer;
            cell.config = config;
            return cell;
        },

        //return the cellRenderer instance for renderering fixed col cells
        getFixedColCell: function(config) {
            var cell = this.cellCache.simpleCellRenderer;
            cell.config = config;
            return cell;
        },

        //return the cellRenderer instance for renderering fixed row cells
        getFixedRowCell: function(config) {
            var cell = this.cellCache.simpleCellRenderer;
            cell.config = config;
            return cell;
        },

        //This is the default cell rendering function for rendering a vanilla cell. Great care was taken in crafting this function as it needs to perform extremely fast. Reads on the gc object are expensive but not quite as expensive as writes to it. We do our best to avoid writes, then avoid reads. Clipping bounds are not set here as this is also an expensive operation. Instead, we truncate overflowing text and content by filling a rectangle with background color column by column instead of cell by cell.  This column by column fill happens higher up on the stack in a calling function from OFGridRenderer.  Take note we do not do cell by cell border renderering as that is expensive.  Instead we render many fewer gridlines after all cells are rendered.

        defaultCellPaint: function(gc, x, y, width, height) {

            var colHEdgeOffset = constants.cellPadding,
                halignOffset = 0,
                valignOffset = 0,
                halign = this.config.halign,
                size,
                textWidth;

            //setting gc properties are expensive, lets not do it unnecessarily
            if (gc.font !== this.config.font) {
                gc.font = this.config.font;
            }
            if (gc.textAlign !== 'left') {
                gc.textAlign = 'left';
            }
            if (gc.textBasline !== 'middle') {
                gc.textBaseline = 'middle';
            }

            //don't measure the text if we don't have to as it is very expensive
            if (halign === 'right') {
                size = gc.measureText(this.config.value);
                textWidth = size.width;
                halignOffset = width - colHEdgeOffset - textWidth;
            } else if (halign === 'center') {
                size = gc.measureText(this.config.value);
                textWidth = size.width;
                halignOffset = (width - textWidth) / 2;
            } else if (halign === 'left') {
                halignOffset = colHEdgeOffset;
            }

            halignOffset = Math.max(0, halignOffset);
            valignOffset = height / 2;

            //fill background only if our bgColor is populated or we are a selected cell
            if (this.config.bgColor || this.config.isSelected) {
                gc.fillStyle = this.config.isSelected ? this.config.bgSelColor : this.config.bgColor;
                gc.fillRect(x, y, width, height);
            }

            //draw text
            gc.fillStyle = this.config.fgColor;
            gc.fillText(this.config.value, x + halignOffset, y + valignOffset);

        },

        //emersons paint function for a slider button. currently the user cannot interact with it
        paintSlider: function(ctx, x, y, width, height) {
            ctx.strokeStyle = 'white';
            var val = this.config.value;
            var radius = height / 2;
            var offset = width * val;
            var bgColor = this.config.isSelected ? this.config.bgSelColor : '#333333';
            var btnGradient = ctx.createLinearGradient(x, y, x, y + height);
            btnGradient.addColorStop(0, bgColor);
            btnGradient.addColorStop(1, '#666666');
            var arcGradient = ctx.createLinearGradient(x, y, x, y + height);
            arcGradient.addColorStop(0, '#aaaaaa');
            arcGradient.addColorStop(1, '#777777');
            ctx.fillStyle = btnGradient;
            roundRect(ctx, x, y, width, height, radius, btnGradient);
            if (val < 1.0) {
                ctx.fillStyle = arcGradient;
            } else {
                ctx.fillStyle = '#eeeeee';
            }
            ctx.beginPath();
            ctx.arc(x + Math.max(offset - radius, radius), y + radius, radius, 0, 2 * Math.PI);
            ctx.fill();
        },

        //simple implementation of a sparkline.  see [Edward Tufte sparkline](http://www.edwardtufte.com/bboard/q-and-a-fetch-msg?msg_id=0001OR)
        paintSparkbar: function(ctx, x, y, width, height) {
            var val = this.config.value;
            if (!val || !val.length) {
                return;
            }
            var count = val.length;
            var eWidth = width / count;
            var bgColor = this.config.isSelected ? this.config.bgSelColor : 'white';
            ctx.fillStyle = bgColor;
            ctx.fillRect(x, y, width, height);
            ctx.fillStyle = '#010167';
            for (var i = 0; i < val.length; i++) {
                var barheight = val[i] / 110 * height;
                ctx.fillRect(x + 5, y + height - barheight, eWidth * 0.6666, barheight);
                x = x + eWidth;
            }
        },

        //simple implementation of a sparkline, because it's a barchart we've changed the name ;).  see [Edward Tufte sparkline](http://www.edwardtufte.com/bboard/q-and-a-fetch-msg?msg_id=0001OR)
        paintSparkline: function(ctx, x, y, width, height) {
            var val = this.config.value;
            if (!val || !val.length) {
                return;
            }
            var count = val.length;
            var eWidth = width / count;
            var bgColor = this.config.isSelected ? this.config.bgSelColor : 'white';
            ctx.fillStyle = bgColor;
            ctx.fillRect(x, y, width, height);
            ctx.strokeStyle = '#010167';
            ctx.fillStyle = '#010167';
            ctx.beginPath();
            var prev;
            for (var i = 0; i < val.length; i++) {
                var barheight = val[i] / 110 * height;
                if (!prev) {
                    prev = barheight;
                }
                ctx.lineTo(x + 5, y + height - barheight);
                ctx.arc(x + 5, y + height - barheight, 1, 0, 2 * Math.PI, false);
                x = x + eWidth;
            }
            ctx.stroke();
        },

        //default cellRenderers are initialized here.  you can augment the visible on your cellProvider instance: field ```myCellProviderInstance.cellCache.myCellRendererName = myCellRenderer```
        initializeCells: function() {
            this.cellCache.simpleCellRenderer = {
                paint: this.defaultCellPaint
            };
            this.cellCache.sliderCellRenderer = {
                paint: this.paintSlider
            };
            this.cellCache.sparkbarCellRenderer = {
                paint: this.paintSparkbar
            };
            this.cellCache.sparklineCellRenderer = {
                paint: this.paintSparkline
            };
        },

    });
})(); /* jslint ignore:line */

  </script>
</polymer-element>
<polymer-element name="fin-hypergrid-behavior-default" assetpath="behaviors/">
  <template></template>
  <script>

'use strict';


(function() {

    var noop = function() {};

    Polymer('fin-hypergrid-behavior-default',{ /* jslint ignore:line */

        ready: function() {
          this.readyInit();
        },

        grid: null,
        editorTypes: ['choice','textfield','color','slider','spinner','date'],

        //this is here just to provide an example of arbitrary
        //column widths<br>heights could be done the same way
        //<br>TODO: this colwidth example should be pushed into
        //<br>InMemoryGridBehavior

        readyInit: function() {
            this.constants = document.createElement('fin-hypergrid-constants').values;
            this.cellProvider = this.createCellProvider();
            this.scrollPositionX = 0;
            this.scrollPositionY = 0;
            this.renderedWidth = 30;
            this.renderedHeight = 60;
            this.values = {}; //for overriding with edit values;
        },
        installOn: function(grid) {
            grid.setBehavior(this);
        },
        getCellProvider: function() {
            return this.cellProvider;
        },

        setGrid: function(finGrid) {
            this.grid = finGrid;
        },

        getGrid: function() {
            return this.grid;
        },

        //override this function on your GridBehavior to have custom cell renderering
        //<br>see [QGridBehavior.createCellProvider()](QGridBehavior.html) for an example
        createCellProvider: function() {
            var provider = document.createElement('fin-hypergrid-cell-provider');
            return provider;
        },

        //provide the data at the x,y coordinate in the grid
        //<br>this function should be overridden by you
        getValue: function(x, y) {
            var override = this.values['p_' + x + '_' + y];
            if (override) {
                return override;
            }
            return '(' + x + ', ' + y + ')';
        },

        //set the data at the x, y
        //<br>this function should be overridden by you
        setValue: function(x, y, value) {
            this.values['p_' + x + '_' + y] = value;
        },

        //fixed rows are the static rows at the top of the grid that don't scroll up or down
        //<br>they can be arbitary width by height in size
        //<br>here we just return an excel-ish base-26 alpha value
        getFixedRowValue: function(x /*, y*/ ) {
            return this.alphaFor(x);
        },

        //fixed cols are the static cols at the left of the grid that don't scroll up or down
        //<br>they can be arbitary width by height in size
        //<br>here we just return an excel-ish base-26 alpha value
        getFixedColValue: function(x, y) {
            return this.alphaFor(y);
        },

        //can be dynamic if your data set changes size
        getRowCount: function() {
            return 5000;
        },

        //can be dynamic if your data set changes size
        getColCount: function() {
            return 300;
        },

        //can be dynamic for supporting "floating" fixed rows
        //<br>floating rows are rows that become fixed if you
        //<br>scroll past them
        getFixedRowCount: function() {
            return 1;
        },

        //pixel height of the fixed rows area
        getFixedRowsHeight: function() {
            var count = this.getFixedRowCount();
            var total = 0;
            for (var i = 0; i < count; i++) {
                total = total + this.getFixedRowHeight(i);
            }
            return total;
        },

        //the height of the specific fixed row
        getFixedRowHeight: function(rowNum) {
            return this.getRowHeight(rowNum);
        },

        //the potential maximum height of the fixed row area
        //<br>TODO: move this logic into the OFGrid itself
        //<br>there should only be getFixedRows, and getMaxFixedRows
        getFixedRowsMaxHeight: function() {
            var height = (0 + this.getFixedRowCount()) * (this.constants.rowHeight);
            return height;
        },

        //can be dynamic for supporting "floating" fixed cols
        //<br>floating cols are cols that become fixed if you
        //<br>scroll past them
        getFixedColCount: function() {
            return 1;
        },

        //pixel width of the fixed cols area
        getFixedColsWidth: function() {
            var count = this.getFixedColCount();
            var total = 0;
            for (var i = 0; i < count; i++) {
                total = total + this.getFixedColWidth(i);
            }
            return total;
        },

        //the potential maximum width of the fixed col area
        //<br>TODO: move this logic into the OFGrid itself
        //<br>there should only be getFixedCols, and getMaxFixedCols
        getFixedColsMaxWidth: function() {
            var width = (0 + this.getFixedColCount()) * (this.constants.colWidth);
            return width;
        },

        //the width of the specific fixed col
        getFixedColWidth: function(colNum) {
            var width = this.getColWidth(colNum);
            return width;
        },

        //can be dynamic if we wish to allow users to resize
        //<br>or driven by data, etc...
        getRowHeight: function( /* rowNum */ ) {
            return this.constants.rowHeight;
        },

        //can be dynamic if we wish to allow users to resize
        //<br>or driven by data, etc...
        //<br>this implementation is driven by modulo
        //<br>TODO: move this example into InMemoryGridBehavior
        getColWidth: function(colNumber) {
            return this.constants.colWidth;
        },

        //this is set by OFGrid on scroll
        //<br>this allows for fast scrolling through rows of very large external data sets
        //<br>this is ignored by in memory GridBehaviors
        setScrollPositionY: function(y) {
            this.scrollPositionY = y;
            this.changed();
        },

        //this is set by OFGrid on scroll
        //<br>this allows for fast scrolling through cols of very large external data sets
        //<br>this is ignored by in memory GridBehaviors
        setScrollPositionX: function(x) {
            this.scrollPositionX = x;
            this.changed();
        },

        //the number of viewable columns we just rendered
        //<br>set by OFGrid on every repaint
        setRenderedWidth: function(width) {
            this.renderedWidth = width;
        },

        //the number of viewable rows we just rendered
        //<br>set by OFGrid on every repaint
        setRenderedHeight: function(height) {
            this.renderedHeight = height;
        },

        //answers the default col alignment for the main data area of the grid
        //<br>TODO:provide uniform mechanism for the fixed areas like this
        getColAlignment: function( /* x */ ) {
            return 'center';
        },

        //this is called by OFGrid when a fixed row cell is clicked
        //<br>see DefaultGridBehavior.delegateClick() below
        //<br>this is where we can hook in external data manipulation such as linking,
        //<br>drilling down on rows, etc...
        fixedRowClicked: function(grid, mouse) {
            console.log('fixed row clicked: ' + mouse.cell.x, mouse);
        },

        //this is called by OFGrid when a fixed col cell is clicked
        //<br>see DefaultGridBehavior.delegateClick() below
        //<br>this is where we can hook in external data manipulation such as sorting,
        //<br>hiding/showing columns, etc...
        fixedColClicked: function(grid, mouse) {
            console.log('fixed col clicked: ' + mouse.cell.y, mouse);
        },

        //this is called by OFGrid when a fixed cell is clicked
        delegateClick: function(grid, mouse) {
            if (mouse.cell.y < this.getFixedRowCount()) {
                this.fixedRowClicked(grid, mouse);
            } else if (mouse.cell.x < this.getFixedColCount()) {
                this.fixedColClicked(grid, mouse);
            }
        },

        //this is called by OFGrid when a fixed cell is clicked
        //<br>TODO:edit functionality needs to be abstracted out
        delegateDoubleClick: function(grid, mouse) {

            var mX = this.scrollPositionX + mouse.cell.x - 1;
            var mY = this.scrollPositionY + mouse.cell.y - 1;

            var editor = this.getCellEditorAt(mX, mY);
            this.getGrid().editAt(editor, mouse);
        },

        getCellEditorAt: function(x, y) {
            var cellEditor = this.grid.cellEditors['textfield'];
            return cellEditor;
        },

        //this is a helper function for generating fixed col/row data
        alphaFor: function(i) {
            // Name the column headers in A, .., AA, AB, AC, .., AZ format
            // quotient/remainder
            //var quo = Math.floor(col/27);
            var quo = Math.floor((i) / 26);
            var rem = (i) % 26;
            var code = '';
            if (quo > 0) {
                code += String.fromCharCode('A'.charCodeAt(0) + quo - 1);
            }
            code += String.fromCharCode('A'.charCodeAt(0) + rem);
            return code;
        },

        //changed function is overridden by the OFGrid when we set this as
        //<br>it's behavior
        //<br>TODO:we should be using event emitter or some other real observer mechanism here
        changed: function() {}

    });

})(); /* jslint ignore:line */

  </script>
</polymer-element>

<polymer-element name="fin-hypergrid-behavior-in-memory" extends="fin-hypergrid-behavior-default" assetpath="behaviors/">
  <template></template>
  <script>

/*jshint  bitwise: false */
'use strict';

(function() {

    var widths = [100, 100, 80, 90, 80, 150, 100, 80, 80, 100];
    //helper function for randomizing data
    function rnd(max) {
        return Math.floor(Math.random() * max);
    }

    //helper data for efficient randomization of the data under the sparkline/bar charts
    var barRandomOffsets = [];
    for (var i = 0; i < 20; i++) {
        barRandomOffsets.push([]);
        for (var r = 0; r < 10; r++) {
            barRandomOffsets[i].push(10 - rnd(20));
        }
    }

    //This is a very rough in memory data source example.  InMemoryGridBehavior is a more traditional gridmodel
    //where all data and its analytics, sorting, aggregation happen in the same process.
    //<br>much of this is loosely based on emerson's original grid POC
    //<br>TODO:needs alot of work/bug-fixing/feature completion/tests/cleanup/commenting here...

    Polymer('fin-hypergrid-behavior-in-memory',{ /* jslint ignore:line */

        ready: function() {
            this.readyInit();
            //milliseconds pause inbetween sweeps of random updates
            this.permuteInterval = 50;
            this.rows = 5000;
            this.cols = 100;
            this.values = new Array(this.rows * this.cols);
            this.order = [];
            this.sorts = [];
            this.sortLookup = {};
            this.sorted = {};
            this.sortStates = [' -', ' ^', ' v'];

            this.createSort(0, 2);
            this.createSort(0, 14);
            this.createSort(0, 22);
            this.initOrder();
            this.initialize();
            this.permute();
            this.reorder();
        },

        //default to left halign for rendering performance improvement
        //<br>and make cols 3, 23, 41 use special cell renderers
        createCellProvider: function() {
            var provider = document.createElement('fin-hypergrid-cell-provider');
            provider.getCell = function(config) {
                var renderer = provider.cellCache.simpleCellRenderer;
                config.halign = 'left';
                var x = config.x;
                if (x === 41) {
                    renderer = provider.cellCache.sliderCellRenderer;
                } else if (x === 23) {
                    renderer = provider.cellCache.sparkbarCellRenderer;
                } else if (x === 3) {
                    renderer = provider.cellCache.sparklineCellRenderer;
                } else if (x === 2) {
                    var hex = Math.floor(config.value * 255 / 100).toString(16);
                    if (hex.length < 1) {
                        hex = '0' + hex;
                    }
                    var bgColor = '#' + '00' + hex + '00';
                    config.bgColor = bgColor;
                }
                renderer.config = config;
                return renderer;
            };
            return provider;
        },

        setValues: function(c) {
            var self = this;
            for (var x = c.xstart; x < c.xstop; x = x + c.xinc) {
                for (var y = c.ystart; y < c.ystop; y = y + c.yinc) {
                    this.setRandomValue(x, y, c.cutoff);
                }
            }
            self.changed();
        },

        //fill in random data
        initialize: function() {
            var config = {
                xstart: 0,
                xstop: this.getColCount(),
                xinc: 1,
                ystart: 0,
                ystop: this.getRowCount(),
                yinc: 1,
                cutoff: 2
            };
            this.setValues(config);
        },

        //kick off randomizing data every 200ms,
        //<br>simulate data streaming in...
        permute: function() {
            var self = this;
            var config = {
                xstart: this.scrollPositionX,
                xstop: this.scrollPositionX + this.renderedWidth,
                xinc: 1,
                ystart: this.scrollPositionY,
                ystop: this.scrollPositionY + this.renderedHeight,
                yinc: 1,
                cutoff: 0.05
            };
            this.setValues(config);
            setTimeout(function() {
                self.permute();
            }, self.permuteInterval);
        },

        getCellEditorAt: function(x, y) {
            var type = x !== 9 ? 'textfield' : this.editorTypes[y % this.editorTypes.length];
            var cellEditor = this.grid.cellEditors[type];
            return cellEditor;
        },
        //set a random value into col/row, cutoff is the threshold to exit if the random value is outside
        setRandomValue: function(col, row, cutoff) {
            var rand = Math.random();
            var val = this.getValue(col, row);
            var rndV;
            if (rand > cutoff) {
                return;
            }
            if (col === 13) {
                val = rand < 0.1 ? true : false;
                this.setValue(col, row, val);
            } else if (col === 23) {
                if (!val) {
                    val = [rnd(100), rnd(100), rnd(100), rnd(100), rnd(100), rnd(100), rnd(100), rnd(100), rnd(100), rnd(100)];
                } else {
                    rndV = Math.floor(60 * rand);
                    if (rndV > 19) {
                        return;
                    }
                    var rndOffsets = barRandomOffsets[rndV];
                    for (var i = 0; i < rndOffsets.length; i++) {
                        val[i] = Math.min(Math.max(0, val[i] + rndOffsets[i]), 100);
                    }
                }
                this.setValue(col, row, val);
            } else if (col === 3) {
                if (!val) {
                    val = [rnd(100), rnd(100), rnd(100), rnd(100), rnd(100), rnd(100), rnd(100), rnd(100), rnd(100), rnd(100)];
                } else {
                    rndV = Math.floor(8000 * rand);
                    if (rndV > 99) {
                        return;
                    }
                    if (val.shift) {
                        val.shift();
                        val.push(rndV);
                    }
                }
                this.setValue(col, row, val);
            } else if (col % 10 === 0) {
                val = [rand < 0.1 ? false : true, 1.0];
                this.setValue(col, row, val);
            } else if (col === 9) {
                if (val) {
                    return; // only set this onece
                }
                var hex = row.toString(16).toUpperCase();
                while (hex.length < 6) {
                    hex = '0' + hex;
                }
                val = '0x' + hex;
                this.setValue(col, row, val);
            } else if (col % 6 === 0) {
                if (val) {
                    return; // only set this onece
                }
                var profound = 'Quidquid latine dictum sit, altum sonatur.';
                this.setValue(col, row, profound);
            } else if (col % 4 === 0) {
                var ipsum = 'Lorem ipsum dolor sit amet, malis repudiare mei in. Cu munere expetendis mea, affert aliquid definiebas at nam. Te scripta delectus singulis mel, et vidit error legere eum, ea latine feugait ponderum vix. Ius ei electram patrioque, et eum propriae deseruisse necessitatibus. Epicurei adipisci ex duo. Quidam iudicabit ullamcorper ex vel, per quot ipsum ad, libris quaeque iudicabit et usu. Ut postea nominavi cum, id eius porro mundi qui. Nec ex altera dolorum definiebas, consul viderer ex est. ';
                var index = Math.max(0, (rand * ipsum.length) - 20);
                val = ipsum.slice(index, index + 20).toUpperCase();
                this.setValue(col, row, val);
            } else if (col === 2 || col === 14 || col === 22) {
                var v = Math.min(Math.floor(rand * 2000), 100);
                this.setValue(col, row, Math.max(v));
            } else if (col === 41) {
                this.setValue(col, row, Math.random());
            } else {
                this.setValue(col, row, rand);
            }
        },

        //int vector indirection layer so sorting doesn't actually move items around
        indexOf: function(row, col) {
            var index = (col * this.rows) + row;
            return index;
        },

        //create a sort object per column we consider sortable
        //TODO:rethink sorting encapsulation
        createSort: function(type, col) {

            var self = this;
            var that = {};
            that.type = type;
            that.col = col;
            that.value = function(array, index) {
                return array[self.indexOf(self.order[index], col)];
            };

            that.compare = function(array, first, last) {

                var x = that.value(array, first),
                    y = that.value(array, last);
                if (typeof(x) === 'number') {
                    // Numbers are compared by subtraction
                    if (that.type === 1) {
                        if (!y) {
                            return -1;
                        }
                        return x - y;
                    } else {
                        if (!y) {
                            return 1;
                        }
                        return y - x;
                    }
                } else {
                    // Anything not a number gets compared using the relational operators
                    if (that.type === 1) {
                        if (!y) {
                            return -1;
                        }
                        return x < y ? -1 : 1;
                    } else {
                        if (!y) {
                            return 1;
                        }
                        return y < x ? -1 : 1;
                    }
                }
                return 0;
            };
            this.sorts.push(that);
            this.sortLookup[col] = that;
        },

        swap: function(array, x, y) {
            var tmp = this.order[x];
            this.order[x] = this.order[y];
            this.order[y] = tmp;
        },

        compare: function(array, first, last) {
            var comp = 0;
            for (var i = 0; i < this.sorts.length; ++i) {
                var sort = this.sorts[i];
                if (sort.type !== 0) {
                    comp = sort.compare(array, first, last);
                    if (comp === 0) {
                        continue;
                    }
                    break;
                }
            }
            return comp;
        },

        //initialize int vector indirection to ascending integers 0 through row count
        initOrder: function() {
            this.order = [];
            // Re-initialise the row order, as this is what we sort, not the actual data.
            for (var i = 0; i < this.rows; ++i) {
                this.order[i] = i;
            }
        },

        //emersons stable quicksort algorithm, hacked up by me
        //<br>TODO: this needs serious attention, could be exposed as part of a bowerized sorting lib
        quicksort: function(array, first, last, depth) {
            // In place quickstort, stable.  We cant use the inbuilt Array.sort() since its a hybrid sort
            // potentially and may not be stable (non quicksort) on small sizes.
            if (depth > 1000) {
                console.log('sort aborted!');
                return;
            }
            var pivot = 0;
            if (depth === 0) {
                // Is there something to sort ??
                if (this.sorts.length <= 0) {
                    return;
                }
                // Optimise for null trailing nulls.
                var sort = this.sorts[0];
                while (!sort.value(array, last) && last > first) {
                    --last;
                }
                // Test for worst case already sorted list...
                var sorted = true;
                for (pivot = first; pivot < last; ++pivot) {
                    if (this.compare(array, pivot, pivot + 1) > 0) {
                        sorted = false;
                        break;
                    }
                }
                if (sorted) {
                    return;
                }
            }
            while (first < last) {
                var right = last;
                var left = first;
                pivot = (first + last) >> 1;
                if (pivot < 0 || pivot >= last) {
                    break;
                }
                while (right >= left) {
                    while (left <= right && this.compare(array, left, pivot) <= 0) {
                        ++left;
                    }
                    while (left <= right && this.compare(array, right, pivot) > 0) {
                        --right;
                    }
                    if (left > right) {
                        break;
                    }
                    this.swap(array, left, right);
                    if (pivot === right) {
                        pivot = left;
                    }
                    left++;
                    right--;
                }
                this.swap(array, pivot, right);
                right--;
                // Use recursion to sort the smallest partition, this increases performance.
                if (Math.abs(right - first) > Math.abs(last - left)) {
                    if (left < last) {
                        this.quicksort(array, left, last, depth + 1);
                    }
                    last = right;
                } else {
                    if (first < right) {
                        this.quicksort(array, first, right, depth + 1);
                    }
                    first = left;
                }
            }
        },

        //invoke the sorting
        reorder: function() {
            this.initOrder();
            this.quicksort(this.values, 0, this.rows - 1, 0);
        },

        //give me the indirect sorted index of the data I'm looking for
        orderOf: function(y) {
            // Provide indirection of indexing for row/col so that we can use sort and or alternate between
            // coloumn and row oriented sotrage.  For example to maximise performance we currently paint by
            // column then row, so it makes sense that the data is stored as column contiguous, but that could
            // be changed if filters or some other feature required it.  Also at the moment sorting is faster
            // if we can just copy a contigious section of the values array, and we sort on columns.
            var row = this.order[y];
            return row;
        },

        //set value through the sorted indirection
        setValue: function(col, y, value) {
            var row = this.orderOf(y);
            var index = this.indexOf(row, col);
            this.values[index] = value;
        },

        // get value through the sorted indirection
        getValue: function(col, y) {
            var row = this.orderOf(y);
            var index = this.indexOf(row, col);
            return this.values[index];
        },

        getFixedColValue: function(x, y) {
            return y;
        },

        getRowCount: function() {
            return this.rows;
        },

        getColCount: function() {
            return this.cols;
        },

        getFixedRowValue: function(x /*, y*/ ) {
            var sortIndicator = '';
            if (this.sortLookup[x] && !this.sorted[x]) {
                this.sorted[x] = 0;
                sortIndicator = this.sortStates[this.sorted[x]];
            }
            if (this.sorted[x]) {
                sortIndicator = this.sortStates[this.sorted[x]];
            }
            return this.alphaFor(x) + sortIndicator;
        },

        //cols 2, 14, 22 are sortable
        fixedRowClicked: function(grid, mouse) {
            var colIndex = this.scrollPositionX + mouse.cell.x - this.getFixedColCount();
            if ([2, 14, 22].indexOf(colIndex) === -1) {
                return;
            }
            this.toggleSort(colIndex);
        },

        toggleSort: function(colIndex) {
            var current = this.sorted[colIndex];
            var stateCount = this.sortStates.length;
            var sortStateIndex = (current + 1) % stateCount;
            this.sorted[colIndex] = sortStateIndex;
            this.sortLookup[colIndex].type = sortStateIndex;
            this.reorder();
            this.changed();
        },

        getColWidth: function(colNum) {
            return widths[colNum % widths.length];
        }
    });

})(); /* jslint ignore:line */

  </script>
</polymer-element>

<polymer-element name="fin-hypergrid-behavior-json" extends="fin-hypergrid-behavior-default" assetpath="behaviors/">
  <template></template>
  <script>

/*jshint  bitwise: false */
'use strict';

var quickSort = function(arr, key) {

  // return if array is unsortable
  if (arr.length <= 1){
    return arr;
  }

  var less = Array(), greater = Array();

  // select and remove a pivot value pivot from array
  // a pivot value closer to median of the dataset may result in better performance
  var pivotIndex = Math.floor(arr.length / 2);
  var pivot = arr.splice(pivotIndex, 1)[0];

  // step through all array elements
  for (var x = 0; x < arr.length; x++){

    // if (current value is less than pivot),
    // OR if (current value is the same as pivot AND this index is less than the index of the pivot in the original array)
    // then push onto end of less array
    if (
      (
        !key  // no object property name passed
        &&
        (
          (arr[x] < pivot)
          ||
          (arr[x] == pivot && x < pivotIndex)  // this maintains the original order of values equal to the pivot
        )
      )
      ||
      (
        key  // object property name passed
        &&
        (
          (arr[x][key] < pivot[key])
          ||
          (arr[x][key] == pivot[key] && x < pivotIndex)  // this maintains the original order of values equal to the pivot
        )
      )
    ){
      less.push(arr[x]);
    }

    // if (current value is greater than pivot),
    // OR if (current value is the same as pivot AND this index is greater than or equal to the index of the pivot in the original array)
    // then push onto end of greater array
    else {
      greater.push(arr[x]);
    }
  }

  // concatenate less+pivot+greater arrays
  return quickSort(less, key).concat([pivot], quickSort(greater, key));
};

(function() {

    Polymer('fin-hypergrid-behavior-json',{ /* jslint ignore:line */

        sorted: {},
        sortStates: [' ', ' ^', ' v'],
        data: [],
        headers: [],
        fields: [],

        setHeaders: function(headerLabels) {
            this.headers = headerLabels;
        },

        setFields: function(fieldNames) {
            this.fields = fieldNames;
        },

        setData: function(jsonData) {
            this.data = jsonData;
            this.changed();
        },

        getValue: function(x, y) {
            return this.data[y][this.fields[x]];
        },

        setValue: function(x, y, value) {
            this.data[y][this.fields[x]] = value;
        },

        getFixedColValue: function(x, y) {
            return y;
        },

        getFixedRowValue: function(x, y) {
            var sortIndex = this.sorted[x] || 0;
            return this.headers[x] + this.sortStates[sortIndex];
        },

        getFixedColCount: function() {
            return 1;
        },

        getRowCount: function() {
            return this.data.length;
        },

        getColCount: function() {
            return this.fields.length;
        },

        fixedRowClicked: function(grid, mouse) {
            var colIndex = this.scrollPositionX + mouse.cell.x - this.getFixedColCount();
            this.toggleSort(colIndex);
        },

        toggleSort: function(colIndex) {
            this.grid.clearSelections();
            if (colIndex >= this.fields.length) {
                return;
            }
            var current = this.sorted[colIndex] || 0;
            var stateCount = this.sortStates.length;
            var sortStateIndex = (current + 1) % stateCount;

            for (var i = 0; i < this.fields.length; i++) {
                this.sorted[i] = 0;
            }

            this.sorted[colIndex] = sortStateIndex;


            var colName = this.fields[colIndex];
            if (sortStateIndex === 0) {

            } else if (sortStateIndex === 1) {
                this.data = quickSort(this.data, colName);
            } else {
                this.data = this.data.reverse();
            }
            this.changed();
        }

    });

})(); /* jslint ignore:line */

  </script>
</polymer-element>

<polymer-element name="fin-hypergrid-behavior-q" extends="fin-hypergrid-behavior-default" attributes="url" assetpath="behaviors/">
  <template></template>
  <script>

'use strict';
//QGridBehavior is a datasource based on an external Q data source.
//<br>See [kx.com](http://www.kx.com)
//<br>Two example scripts are provided in the root of this project, bigtable.q and sorttable.q
//<br>bigtable.q simulates an unsortable 100MM row table, and sorttable.q provides a true randomly generated 1MM row table sortable on any column.
//<br>Run either of these scripts with this GridBehavior.

(function() {

    //keys mapping Q datatypes to aligment and renderers are setup here.
    //<br>see [q datatypes](http://code.kx.com/wiki/Reference/Datatypes) for more.

    var typeAlignmentMap = {
        j: 'right',
        s: 'left',
        t: 'center',
        f: 'right',
        d: 'center'
    };

    //there are 4 default cell renderer types to choose from at the moment
    //<br>simpleCellRenderer, sliderCellRenderer, sparkbarCellRenderer, sparklineCellRenderer
    var typeRendererMap = {
        J: 'sparklineCellRenderer',
        j: 'simpleCellRenderer',
        s: 'simpleCellRenderer',
        t: 'simpleCellRenderer',
        f: 'simpleCellRenderer',
        d: 'simpleCellRenderer'
    };

    //sort states are also the visual queues in the column headers
    //* '' no sort
    //* ^ sort ascending
    //* v sort descending
    //* |^| sort absolute value ascending
    //* |v| sort absolute value descending

    Polymer('fin-hypergrid-behavior-q',{ /* jslint ignore:line */
        ready: function() {
            this.readyInit();
            this.sorted = {};
            this.sortStates = ['', ' ^', ' v', ' |^|', ' |v|'];
            this.ws = null;
            this.url = this.getAttribute('url') || 'ws://localhost:5000/';
            this.connect();
            this.scrollPositionY = 0;
            this.scrolled = false;
            this.block = {
                data: [],
                headers: [],
                rows: 0
            };
        },

        //this is a good example of overriding the default cellprovider
        //<br>in this case config.x is how we specify a column through its index
        createCellProvider: function() {
            var provider = document.createElement('fin-hypergrid-cell-provider');
            var self = this;
            provider.getCell = function(config) {
                var x = config.x;
                var renderer = provider.cellCache[typeRendererMap[self.block.headers[x + 1][1]]];
                if (x === 11) {
                    renderer = provider.cellCache.sliderCellRenderer;
                } else if (x === 13) {
                    renderer = provider.cellCache.sparkbarCellRenderer;
                }
                renderer.config = config;
                return renderer;
            };
            return provider;
        },

        //for now we use the hacky override implementation to save data, in the future we'll have a more elaborate protocol with Q to do real validation and setting of data.
        //<br>take note of the usage of the scrollPositionY value in translating our in-memory data page
        getValue: function(x, y) {
            var override = this.values['p_' + (x + 1) + '_' + y];
            if (override) {
                return override;
            }

            var normalized = Math.floor(y - this.scrollPositionY);
            if (this.block && normalized < this.block.data.length) {
                return this.block.data[normalized][x + 1];
            } else {
                return '';
            }
        },

        //empty out our page of local data, this function is used when we lose connectivity
        //<br>this function is primarily used as a visual queue so the user doesn't see stale data
        clearData: function() {
            this.block.rows = [];
            this.changed();
        },

        //rows is a field in our data payload from Q that tells us the total number of rows available in the Q process data source
        getRowCount: function() {
            return this.block.rows;
        },

        //Virtual column scrolling is not necessary with this GridBehavior because we only hold a small amount of vertical data in memory and most tables in Q are timeseries financial data meaning the are very tall and skinny.  We know all the columns from the first page from Q.
        getColCount: function() {
            return this.block.headers.length - 1;
        },

        //This is overridden from DefaultGridBehavior.   This value is set on us by the OFGrid component on user scrolling.
        //<br>TODO: refactor: don't store this value in an local member, store it in the message ONLY.
        //<br>TODO: refactor: num should be dynamic
        setScrollPositionY: function(y) {
            this.scrollPositionY = y;
            this.ws.send(JSON.stringify({
                cmd: 'fetch',
                data: {
                    start: this.scrollPositionY,
                    num: 60
                }
            }));
        },

        //return the column names, they are available to us as meta data in the most recent page Q sent us.
        getFixedRowValue: function(x) {
            if (!this.sorted[x + 1]) {
                this.sorted[x + 1] = 0;
            }
            var sortIndicator = this.sortStates[this.sorted[x + 1]];
            return this.block.headers[x + 1][0] + sortIndicator;
        },

        //for now just return the row number.  the simple protocol we talk with q assumes the first column is the real row index. so it is offset in all data access
        getFixedColValue: function(x, y) {
            return this.getValue(-1, y);
        },

        //let Q decide if this instance is sortable or not
        getCanSort: function() {
            var canSort = this.block.features.sorting === true;
            return canSort;
        },

        //on a header click do a sort!
        fixedRowClicked: function(grid, mouse) {
            this.toggleSort(this.scrollPositionX + mouse.cell.x - this.getFixedColCount());
        },

        //first ask q if this is a sortable instance, then send a message to Q to sort our data set
        toggleSort: function(colIndex) {
            if (!this.getCanSort()) {
                return;
            }
            colIndex++;
            var current = this.sorted[colIndex];
            var stateCount = this.sortStates.length;
            this.sorted = {}; //clear out other sorted for now, well add multicolumn sort later
            this.sorted[colIndex] = (current + 1) % stateCount;
            var state = this.sortStates[this.sorted[colIndex]];
            var message = {
                cmd: 'sort',
                data: {
                    sort: current === (stateCount - 1) ? '' : this.block.headers[colIndex][0],
                    asc: state.indexOf('^') > 0,
                    abs: state.indexOf('|') > 0,
                    start: this.scrollPositionY,
                    num: 60
                }
            };
            this.ws.send(JSON.stringify(message));
        },

        //delegate column alignment through the map at the top based on the column type
        getColAlignment: function(x) {
            var alignment = typeAlignmentMap[this.block.headers[x + 1][1]];
            return alignment;
        },

        //for now use the cheesy local set data for storing user edits
        setValue: function(x, y, value) {
            this.values['p_' + (x + 1) + '_' + y] = value;
        },

        //websocket connection to Q.  try and do a reconnect after 2 seconds if we fail
        connect: function() {
            var d;
            var oldSize;
            var self = this;
            if ('WebSocket' in window) {
                this.ws = new WebSocket(this.url);
                console.log('connecting...');
                this.ws.onopen = function() {
                    console.log('connected');
                    self.ws.send(JSON.stringify({
                        cmd: 'fetch',
                        data: {
                            start: this.scrollPositionY || 0,
                            num: 60
                        }
                    }));
                };
                this.ws.onclose = function() {
                    self.clearData();
                    console.log('disconnected from ' + this.url + ', trying to reconnect in a moment...');
                    setTimeout(function() {
                        self.connect();
                    }, 2000);
                };
                this.ws.onmessage = function(e) {
                    d = JSON.parse(e.data);
                    oldSize = self.block.rows;

                    self.block = d;

                    if (d.rows !== oldSize) {
                        self.sizeChanged();
                    }

                    self.changed();
                };
                this.ws.onerror = function(e) {
                    self.clearData();
                    console.error('problem with connection to q at ' + this.url + ', trying again in a moment...', e.data);
                    setTimeout(function() {
                        self.connect();
                    }, 2000);
                };
            } else {
                console.error('WebSockets not supported on your browser.');
            }
        }

    });

})(); /* jslint ignore:line */

  </script>
</polymer-element>

<polymer-element name="fin-hypergrid-excel" assetpath="">
  <template></template>
  <script>


(function() {

'use strict';

    var createExcelDataFromSelections = function(grid) {
        //only use the data from the last selection
        var selectionModel = grid.getSelectionModel();
        var selections = selectionModel.getSelections();
        if (selections.length === 0) {
            return;
        }
        var behavior = grid.getBehavior();
        var collector = [];
        var obj;
        for (var i = 0; i < selections.length; i++) {
            var each = selections[i];
            var eachData = [];
            var xstart = each.origin.x;
            var xstop = each.origin.x + each.extent.x + 1;
            var ystart = each.origin.y;
            var ystop = each.origin.y + each.extent.y + 1;
            for (var y = ystart; y < ystop; y++) {
                for (var x = xstart; x < xstop; x++) {
                    var data = behavior.getValue(x, y);
                    eachData.push(data + '');
                }
            }
            obj = {
                region: [ystart, xstart, ystop - 1, xstop - 1],
                values: eachData
            };
            collector.push(obj);
        }
        obj = {
            now: new Date().getTime(),
            selection: collector
        };
        return obj;
    };

    var publish = function(grid) {

        if (!grid.hasSelections()) {
            return;
        }

        var excelMessage = createExcelDataFromSelections(grid);
        fin.desktop.InterApplicationBus.publish('onSelect', excelMessage);

        console.log('push to excel', excelMessage);
    };

    var subscribe = function(grid) {
        var sm = grid.getSelectionModel();
        fin.desktop.InterApplicationBus.subscribe('*', 'onExcelChange', function(data) {
            console.log(JSON.stringify(data));
            if (data.cells && data.cells.length > 0) {
                data.cells.forEach(function(cell) {
                    if (cell.value && !sm.isSelected(cell.row, cell.column)) {
                        grid.setValue(cell.column, cell.row, cell.value);
                    }
                });
            }
        });

        fin.desktop.InterApplicationBus.subscribe('*', 'ExcelError', function(data) {
            console.log(JSON.stringify(data));
        });
    };

    var excel = function(grid) {
        // Entry point to the App Desktop
        if (!fin) {
            console.error('Excel integration only works within the OpenFin Runtime');
            return;
        }
        fin.desktop.main(function() {
            fin.desktop.Application.getCurrent();

            // This should be the same interval as the cells layer
            setInterval(function() {
                publish(grid);
            }, 1000 / 2);

            subscribe(grid);
        });
    };

    if (!window.fin) { //jshint ignore:line
        //if openfin isn't present we should do nothing
        excel = function() {};
    }

    Polymer('fin-hypergrid-excel',{ /* jshint ignore:line */
        installOn: excel
    });

})(); /* jshint ignore:line */

  </script>
</polymer-element>



<scripts>
	<script>
	(function() {
		// evacipate all scripts in parent!
		if (window.WebComponents) {
			var scripts = document._currentScript.parentNode;
			scripts.parentNode.removeChild(scripts);
		}
	})();
	</script>
	<script src="../polymer/src/system/compat.js"></script>
	<script src="../polymer/src/system/HTMLImports/base.js"></script>
	<script src="../polymer/src/system/unresolved.js"></script>
</scripts>

<script src="../observe-js/src/observe.js"></script>
<script src="../NodeBind/src/NodeBind.js"></script>
<script src="../TemplateBinding/src/TemplateBinding.js"></script>
<script src="../URL/url.js"></script>
<script src="../polymer/src/system/microtask.js"></script>
<script src="../polymer/src/system/flush.js"></script>

<script src="../polymer/src/lib/url.js"></script>
<script src="../polymer/src/lib/loader.js"></script>
<script src="../polymer/src/lib/styleloader.js"></script>
<script src="../polymer/src/lib/lang.js"></script>
<script src="../polymer/src/lib/job.js"></script>
<script src="../polymer/src/lib/dom.js"></script>
<script src="../polymer/src/lib/super.js"></script>
<script src="../polymer/src/lib/deserialize.js"></script>
<script src="../polymer/src/api.js"></script>
<script src="../polymer/src/instance/utils.js"></script>
<script src="../polymer/src/instance/events.js"></script>
<script src="../polymer/src/instance/attributes.js"></script>
<script src="../polymer/src/instance/properties.js"></script>
<script src="../polymer/src/instance/mdv.js"></script>
<script src="../polymer/src/instance/base.js"></script>
<script src="../polymer/src/instance/styles.js"></script>
<script src="../polymer/src/declaration/polymer.js"></script>
<script src="../polymer/src/declaration/path.js"></script>
<script src="../polymer/src/declaration/styles.js"></script>
<script src="../polymer/src/declaration/events.js"></script>
<script src="../polymer/src/declaration/properties.js"></script>
<script src="../polymer/src/declaration/attributes.js"></script>
<script src="../polymer/src/declaration/mdv.js"></script>
<script src="../polymer/src/declaration/prototype.js"></script>
<script src="../polymer/src/declaration/queue.js"></script>
<script src="../polymer/src/declaration/polymer-element.js"></script>
<script src="../polymer/src/lib/import.js"></script>
<script src="../polymer/src/lib/auto-binding.js"></script>

<polymer-element name="fin-rectangle" assetpath="../fin-rectangle/">
  <script>

'use strict';

(function() {

    function rectangleContains(rect, x, y) {
        var minX = rect.origin.x;
        var minY = rect.origin.y;
        var maxX = minX + rect.extent.x;
        var maxY = minY + rect.extent.y;

        if (rect.extent.x < 0) {
            minX = maxX;
            maxX = rect.origin.x;
        }

        if (rect.extent.y < 0) {
            minY = maxY;
            maxY = rect.origin.y;
        }

        var result =
            x >= minX &&
            y >= minY &&
            x <= maxX &&
            y <= maxY;

        return result;
    }

    function createPoint(x, y) {

        var that = {};

        /**
         * The x of this point expressed as a number,
         *
         * @property point.x
         * @type number
         * @default '0'
         */
        Object.defineProperty(that, 'x', {
            value: x || 0,
            writable: false,
            enumerable: true,
            configurable: false
        });


        /**
         * The y of this point expressed as a number,
         *
         * @property point.y
         * @type number
         * @default '0'
         */
        Object.defineProperty(that, 'y', {
            value: y || 0,
            writable: false,
            enumerable: true,
            configurable: false
        });


        /**
         *                                                                      .
         *                                                                      .
         * returns an instance of point that is the sum of self and the argument.
         *
         * @method point.plus(point)
         * @param {point} a point to add to self
         * @returns {point} point object.
         */
        that.plus = function(point) {
            var result = createPoint(this.x + point.x, y + point.y);
            return result;
        };


        /**
         *                                                                      .
         *                                                                      .
         * returns an instance of point that is the difference of self and the argument.
         *
         * @method point.minus(point)
         * @param {point} a point to subtract from self
         * @returns {point} point object.
         */
        that.minus = function(point) {
            var result = createPoint(x - point.x, y - point.y);
            return result;
        };


        /**
         *                                                                      .
         *                                                                      .
         * returns an instance of point that is the min x and y of self and the argument.
         *
         * @method point.min(point)
         * @param {point} a point to source min x and min y against self
         * @returns {point} point object.
         */
        that.min = function(point) {
            var result = createPoint(Math.min(x, point.x), Math.min(y, point.y));
            return result;
        };


        /**
         *                                                                      .
         *                                                                      .
         * returns an instance of point that is the max x and y of self and the argument.
         *
         * @method point.max(point)
         * @param {point} a point to source max x and max y against self
         * @returns {point} point object.
         */
        that.max = function(point) {
            var result = createPoint(Math.max(x, point.x), Math.max(y, point.y));
            return result;
        };

        /**
         *                                                                      .
         *                                                                      .
         * returns distance between the argment and self using the distance formula.
         *
         * @method point.distance(point)
         * @param {point} a point to compute the distance from self
         * @returns {Number} number object.
         */
        that.distance = function(point) {
            var dx = point.x - x,
                dy = point.y - y,
                result = Math.sqrt((dx * dx) + (dy * dy));
            return result;
        };

        /**
         *                                                                      .
         *                                                                      .
         * returns if both x and y of self is greater than that of the argument.
         *
         * @method point.greaterThan(point)
         * @param {point} a point to compare against self
         * @returns {boolean} boolean value.
         */
        that.greaterThan = function(point) {
            var result = this.x > point.x && y > point.y;
            return result;
        };

        /**
         *                                                                      .
         *                                                                      .
         * returns if both x and y of self is less than that of the argument.
         *
         * @method point.lessThan(point)
         * @param {point} a point to compare against self
         * @returns {boolean} boolean value.
         */
        that.lessThan = function(point) {
            var result = this.x < point.x && y < point.y;
            return result;
        };

        /**
         *                                                                      .
         *                                                                      .
         * returns if both x and y of self is greater than or equal to that of the argument.
         *
         * @method point.greaterThanEqualTo(point)
         * @param {point} a point to compare against self
         * @returns {boolean} boolean value.
         */
        that.greaterThanEqualTo = function(point) {
            var result = this.x >= point.x && y >= point.y;
            return result;
        };

        /**
         *                                                                      .
         *                                                                      .
         * returns if both x and y of self is less than or equal to that of the argument.
         *
         * @method point.lessThanEqualTo(point)
         * @param {point} a point to compare against self
         * @returns {boolean} boolean value.
         */
        that.lessThanEqualTo = function(point) {
            var result = this.x <= point.x && y <= point.y;
            return result;
        };
        that.isContainedWithinRectangle = function(rect) {
            return rectangleContains(rect, this.x, this.y);
        };
        return that;
    }

    function createRectangle(x, y, width, height) {

        var that = {};

        /**
         * The origin of this rectangle expressed as a point object,
         *
         * @property rectangle.origin
         * @type point
         * @default 'point at 0,0'
         */
        var origin = createPoint(x, y);

        /**
         * The extent of this rectangle expressed as a point object,
         *
         * @property rectangle.extent
         * @type point
         * @default 'point at 0,0'
         */
        var extent = createPoint(width, height);

        /**
         * The corner of this rectangle expressed as a point object,
         *
         * @property rectangle.corner
         * @type point
         * @default 'point at 0,0'
         */
        var corner = createPoint(x + width, y + height);

        /**
         * The center of this rectangle expressed as a point object,
         *
         * @property rectangle.center
         * @type point
         * @default 'point at 0,0'
         */
        var center = createPoint(x + (width / 2), y + (height / 2));

        Object.defineProperty(that, 'origin', {
            value: origin,
            writable: false,
            enumerable: true,
            configurable: false
        });

        Object.defineProperty(that, 'extent', {
            value: extent,
            writable: false,
            enumerable: true,
            configurable: false
        });

        Object.defineProperty(that, 'corner', {
            value: corner,
            writable: false,
            enumerable: true,
            configurable: false
        });

        Object.defineProperty(that, 'center', {
            value: center,
            writable: false,
            enumerable: true,
            configurable: false
        });

        /**
         *                                                                      .
         *                                                                      .
         * returns this.origin.y, this may need to change
         *
         * @method rectangle.top()
         */
        that.top = function() {
            return this.origin.y;
        };

        /**
         *                                                                      .
         *                                                                      .
         * returns this.origin.x, this may need to change
         *
         * @method rectangle.left()
         */
        that.left = function() {
            return this.origin.x;
        };

        /**
         *                                                                      .
         *                                                                      .
         * returns this.top() + this.extent.y, this may need to change
         *
         * @method rectangle.bottom()
         */
        that.bottom = function() {
            return this.top() + this.extent.y;
        };

        /**
         *                                                                      .
         *                                                                      .
         * returns this.left() + this.extent.x, this may need to change
         *
         * @method rectangle.right()
         */
        that.right = function() {
            return this.left() + this.extent.x;
        };

        /**
         *                                                                      .
         *                                                                      .
         * returns this.extent.x
         *
         * @method rectangle.width()
         */
        that.width = function() {
            return this.extent.x;
        };

        /**
         *                                                                      .
         *                                                                      .
         * returns this.extent.y
         *
         * @method rectangle.height()
         */
        that.height = function() {
            return this.extent.y;
        };

        /**
         *                                                                      .
         *                                                                      .
         * returns this.extent.x * this.extent.y
         *
         * @method rectangle.area()
         */
        that.area = function() {
            return this.extent.x * this.extent.y;
        };

        /**
         *                                                                      .
         *                                                                      .
         * returns a rectangle width 0 and origin x set to argument
         *
         * @method rectangle.flattenXAt(x)
         */
        that.flattenXAt = function(x) {
            var o = this.origin;
            var e = this.extent;
            return createRectangle(x, o.y, 0, e.y);
        };

        /**
         *                                                                      .
         *                                                                      .
         * returns a rectangle height 0 and origin y set to argument
         *
         * @method rectangle.flattenYAt(y)
         */
        that.flattenYAt = function(y) {
            var o = this.origin;
            var e = this.extent;
            return createRectangle(o.x, y, e.x, 0);
        };

        /**
         *                                                                      .
         *                                                                      .
         * returns true if argument point or rectangle is entirely contained inside self
         *
         * @method rectangle.contains(pointOrRect)
         */
        that.contains = function(pointOrRect) {
            var result = pointOrRect.isContainedWithinRectangle(this);
            return result;
        };

        that.isContainedWithinRectangle = function(rect) {
            var result = rect.origin.lessThanEqualTo(this.origin) && rect.corner.greaterThanEqualTo(this.corner);
            return result;
        };

        /**
         *                                                                      .
         *                                                                      .
         * return a Rectangle that is enlarged/shrunk by argument size
         *
         * @method rectangle.insetBy(thickness)
         */
        that.insetBy = function(thickness) {
            var result = createRectangle(
                this.origin.x + thickness,
                this.origin.y + thickness,
                this.extent.x - 2 * thickness,
                this.extent.y - 2 * thickness);
            return result;
        };

        /**
         *                                                                      .
         *                                                                      .
         * return a Rectangle that contains the receiver and the argument
         *
         * @method rectangle.union(rectangle)
         */
        that.union = function(rectangle) {

            var anOrigin = this.origin.min(rectangle.origin),
                aCorner = this.corner.max(rectangle.corner),
                width = aCorner.x - anOrigin.x,
                height = aCorner.y - anOrigin.y,
                result = createRectangle(anOrigin.x, anOrigin.y, width, height);

            return result;
        };

        /**
         *                                                                      .
         *                                                                      .
         * iterate over all points inside me calling function(x,y) for each
         *
         * @method rectangle.forEach(function)
         */
        that.forEach = function(func) {
            var xstart = this.origin.x;
            var xstop = this.origin.x + this.extent.x;
            var ystart = this.origin.y;
            var ystop = this.origin.y + this.extent.y;
            for (var x = xstart; x < xstop; x++) {
                for (var y = ystart; y < ystop; y++) {
                    func(x, y);
                }
            }
        };

        /**
         *                                                                      .
         *                                                                      .
         * returns a Rectangle that is the area in which the receiver overlaps with the argument.  ifNoneAction is called if there is no intersection; it has arguments this and rectangle passed in
         *
         * @method rectangle.intersect(rectangle,ifNoneAction)
         */
        that.intersect = function(rectangle, ifNoneAction) {

            var point = rectangle.origin,
                myCorner = this.corner,
                left = null,
                right = null,
                top = null,
                bottom = null,
                result = null;

            if (ifNoneAction && !this.intersects(rectangle)) {
                return ifNoneAction.call(this, rectangle);
            }

            if (point.x > this.origin.x) {
                left = point.x;
            } else {
                left = this.origin.x;
            }

            if (point.y > this.origin.y) {
                top = point.y;
            } else {
                top = this.origin.y;
            }

            point = rectangle.corner;
            if (point.x < myCorner.x) {
                right = point.x;
            } else {
                right = myCorner.x;
            }

            if (point.y < myCorner.y) {
                bottom = point.y;
            } else {
                bottom = myCorner.y;
            }
            result = createRectangle(left, top, right - left, bottom - top);
            return result;
        };

        /**
         *                                                                      .
         *                                                                      .
         * returns true if we overlap with the argument, false otherwise
         *
         * @method rectangle.intersects(rectangle)
         */
        that.intersects = function(rectangle) {

            var rOrigin = rectangle.origin,
                rCorner = rectangle.corner;

            if (rCorner.x <= this.origin.x) {
                return false;
            }
            if (rCorner.y <= this.origin.y) {
                return false;
            }
            if (rOrigin.x >= this.corner.x) {
                return false;
            }
            if (rOrigin.y >= this.corner.y) {
                return false;
            }
            return true;
        };

        return that;
    }

    /**
     *                                                                        .
     *                                                                      .
     * returns an instance of point.
     *
     * @method static.point.create(x,y)
     * @param {Number} the x coordinate
     *    @param {Number} the y coordinate.
     * @returns {point} point object.
     */

    /**
     *                                                                      .
     *                                                                      .
     * returns an instance of rectangle.
     *
     * @method static.rectangle.create(ox,oy,ex,ey)
     * @param {Number} the x origin coordinate
     *    @param {Number} the y origin coordinate.
     *    @param {Number} the width extent.
     *    @param {Number} the height extent.
     * @returns {rectangle} rectangle object.
     */

    /**
     *                                                                      .
     *                                                                      .
     * returns if a rectangle contains x, y.
     *
     * @method static.rectangle.contains(rectangle,x,y)
     * @param {rectangle} an instance of rectangle
     *    @param {Number} the x coordinate.
     *    @param {Number} the y coordinate.
     * @returns {rectangle} rectangle object.
     */
    Polymer('fin-rectangle', { /* jshint ignore:line  */
        point: {
            create: createPoint
        },
        rectangle: {
            create: createRectangle,
            contains: rectangleContains
        }
    });

})();

  </script>
</polymer-element>
<polymer-element name="fin-canvas" assetpath="../fin-canvas/">
  <template>
    <style>:host {
    overflow: hidden;
    position: absolute;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
}
button {
  position: fixed;
  top: 0px;
  left: 0px;
  height: 0px;
  width: 0px;
  border: none;
  color: transparent;
  background-color: transparent;
  outline: none;
}
div.container {
  position: relative;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
}
</style>
    <button></button>
    <canvas class="canvas"></canvas>
  </template>
  <script>

'use strict';
/* globals document, requestAnimationFrame, CustomEvent */

(function() {

    /**
     * charMap is a private property that maps keys strokes to key chars,
     *
     * @property charMap
     * @type Array
     */
    var charMap = [];
    var empty = ['', ''];
    for (var i = 0; i < 256; i++) {
        charMap[i] = empty;
    }

    charMap[27] = ['ESC', 'ESCSHIFT'];
    charMap[192] = ['`', '~'];
    charMap[49] = ['1', '!'];
    charMap[50] = ['2', '@'];
    charMap[51] = ['3', '#'];
    charMap[52] = ['4', '$'];
    charMap[53] = ['5', '%'];
    charMap[54] = ['6', '^'];
    charMap[55] = ['7', '&'];
    charMap[56] = ['8', '*'];
    charMap[57] = ['9', '('];
    charMap[48] = ['0', ')'];
    charMap[189] = ['-', '_'];
    charMap[187] = ['=', '+'];
    charMap[8] = ['DELETE', 'DELETESHIFT'];
    charMap[9] = ['TAB', 'TABSHIFT'];
    charMap[81] = ['q', 'Q'];
    charMap[87] = ['w', 'W'];
    charMap[69] = ['e', 'E'];
    charMap[82] = ['r', 'R'];
    charMap[84] = ['t', 'T'];
    charMap[89] = ['y', 'Y'];
    charMap[85] = ['u', 'U'];
    charMap[73] = ['i', 'I'];
    charMap[79] = ['o', 'O'];
    charMap[80] = ['p', 'P'];
    charMap[219] = ['[', '{'];
    charMap[221] = [']', '}'];
    charMap[220] = ['\\', '|'];
    charMap[220] = ['CAPSLOCK', 'CAPSLOCKSHIFT'];
    charMap[65] = ['a', 'A'];
    charMap[83] = ['s', 'S'];
    charMap[68] = ['d', 'D'];
    charMap[70] = ['f', 'F'];
    charMap[71] = ['g', 'G'];
    charMap[72] = ['h', 'H'];
    charMap[74] = ['j', 'J'];
    charMap[75] = ['k', 'K'];
    charMap[76] = ['l', 'L'];
    charMap[186] = [';', ':'];
    charMap[222] = ['\'', '|'];
    charMap[13] = ['RETURN', 'RETURNSHIFT'];
    charMap[16] = ['SHIFT', 'SHIFT'];
    charMap[90] = ['z', 'Z'];
    charMap[88] = ['x', 'X'];
    charMap[67] = ['c', 'C'];
    charMap[86] = ['v', 'V'];
    charMap[66] = ['b', 'B'];
    charMap[78] = ['n', 'N'];
    charMap[77] = ['m', 'M'];
    charMap[188] = [',', '<'];
    charMap[190] = ['.', '>'];
    charMap[191] = ['/', '?'];
    charMap[16] = ['SHIFT', 'SHIFT'];
    charMap[17] = ['CTRL', 'CTRLSHIFT'];
    charMap[18] = ['ALT', 'ALTSHIFT'];
    charMap[91] = ['COMMANDLEFT', 'COMMANDLEFTSHIFT'];
    charMap[32] = ['SPACE', 'SPACESHIFT'];
    charMap[93] = ['COMMANDRIGHT', 'COMMANDRIGHTSHIFT'];
    charMap[18] = ['ALT', 'ALTSHIFT'];
    charMap[38] = ['UP', 'UPSHIFT'];
    charMap[37] = ['LEFT', 'LEFTSHIFT'];
    charMap[40] = ['DOWN', 'DOWNSHIFT'];
    charMap[39] = ['RIGHT', 'RIGHTSHIFT'];

    Polymer('fin-canvas', { /* jshint ignore:line */
        /**                                                             .
         * g is the [fin-rectangle](http://stevewirts.github.io/fin-rectangle/components/fin-rectangle/) factory for creating instances of rectangle and point
         *
         * @property g
         * @type fin-rectangle polymer-element
         */
        g: null,

        /**                                                             .
         * canvas is the actual rendering surface that bit-blit to from the buffer
         *
         * @property canvas
         * @type HTMLCanvasElement
         */
        canvas: null,

        /**                                                             .
         * cavasCTX is the cached graphics context from canvas we bit blit to
         *
         * @property cavasCTX
         * @type 2DRenderingContext
         */
        cavasCTX: null,

        /**                                                             .
         * focuser is a button element that is used to simulate proper focus semantics
         *
         * @property focuser
         * @type HTMLButtonElement
         */
        focuser: null,

        /**                                                             .
         * buffer is the offscreen canvas component we draw to that will eventually be bit blit to canvas
         *
         * @property buffer
         * @type HTMLCanvasElement
         */
        buffer: null,

        /**                                                             .
         * ctx is the offscreen cached graphics context from buffer that we draw to
         *
         * @property ctx
         * @type 2DRenderingContext
         */
        ctx: null,

        /**                                                             .
         * fps is how many times a second we check the repaint flag for redrawing
         *
         * @property fps
         * @type Number
         */
        fps: null,

        /**                                                             .
         * mouseLocation is the current position of the mouse pointer
         *
         * @property mouseLocation
         * @type point
         */
        mouseLocation: null,

        /**                                                             .
         * dragstart is the origin of a drag region for the selection
         *
         * @property dragstart
         * @type point
         */
        dragstart: null,

        /**                                                             .
         * origin location of the top right corner of the grid according to [getBoundingClientRect](https://developer.mozilla.org/en-US/docs/Web/API/Element.getBoundingClientRect)
         *
         * @property origin
         * @type point
         */
        origin: null,

        /**                                                             .
         * bounds is a private property that maps keys strokes to key chars,
         *
         * @property bounds
         * @type Array
         */
        bounds: null,

        /**                                                             .
         * repaintNow is a private property that maps keys strokes to key chars,
         *
         * @property repaintNow
         * @type Array
         */
        repaintNow: false,

        /**                                                             .
         * size is a private property that maps keys strokes to key chars,
         *
         * @property size
         * @type Array
         */
        size: null,

        /**                                                             .
         * mousedown is a private property that maps keys strokes to key chars,
         *
         * @property mousedown
         * @type Array
         */
        mousedown: false,

        /**                                                             .
         * dragging is true if we are currently dragging
         *
         * @property dragging
         * @type boolean
         */
        dragging: false,

        /**                                                             .
         * focused is true if we currently have input focus
         *
         * @property focused
         * @type boolean
         */
        focused: false,

        /**                                                             .
         * repeatKeyCount is how many times we've recieved a key down event from the user holding a key down
         *
         * @property repeatKeyCount
         * @type Number
         */
        repeatKeyCount: 0,

        /**                                                             .
         * repeatKey is the key that is currently being held down
         *
         * @property repeatKey
         * @type char
         */
        repeatKey: null,

        /**                                                             .
         * repeatKeyStartTime is the start time in milliseconds of the initial keydown event of a key that is being held down
         *
         * @property repeatKeyStartTime
         * @type Number
         */
        repeatKeyStartTime: 0,

        /**                                                             .
         * currentKeys is an array of the all the keys that are currently being pressed
         *
         * @property currentKeys
         * @type Array
         */
        currentKeys: [],


        /**
         *                                                                      .
         *                                                                      .
         * the number of times per second we check the repaint flag to execute a repaint
         *
         * @attribute fps
         * @default 60
         * @type Number
         */

        /**
         *                                                                      .
         *                                                                      .
         * a polymer lifecycle callback to initialize the canvas
         *
         * @method ready()
         */
        ready: function() {

            this.g = document.createElement('fin-rectangle');
            var self = this;
            this.canvas = this.shadowRoot.querySelector('.canvas');
            this.focuser = this.shadowRoot.querySelector('button');
            this.canvasCTX = this.canvas.getContext('2d');

            this.buffer = document.createElement('canvas');
            this.ctx = this.buffer.getContext('2d');

            this.fps = this.getAttribute('fps') || 60;

            this.mouseLocation = this.g.point.create(-1, -1);
            this.dragstart = this.g.point.create(-1, -1);
            this.origin = this.g.point.create(0, 0);
            this.bounds = this.g.rectangle.create(0, 0, 0, 0);

            document.addEventListener('mousemove', function(e) {
                self.finmousemove(e);
            });
            document.addEventListener('mouseup', function(e) {
                self.finmouseup(e);
            });
            this.focuser.addEventListener('focus', function(e) {
                self.finfocusgained(e);
            });
            this.focuser.addEventListener('blur', function(e) {
                self.finfocuslost(e);
            });
            this.addEventListener('mousedown', function(e) {
                self.finmousedown(e);
            });
            this.addEventListener('mouseout', function(e) {
                self.finmouseout(e);
            });
            document.addEventListener('keydown', function(e) {
                self.finkeydown(e);
            });
            document.addEventListener('keyup', function(e) {
                self.finkeyup(e);
            });
            this.addEventListener('click', function(e) {
                self.finclick(e);
            });
            this.addEventListener('dblclick', function(e) {
                self.findblclick(e);
            });

            this.resize();
            this.beginPainting();
        },

        /**
         *                                                                      .
         *                                                                      .
         * return my one child fin-canvas-component
         *
         * @method getComponent()
         */
        getComponent: function() {
            var comp = this.children[0];
            return comp;
        },

        /**
         *                                                                      .
         *                                                                      .
         * start the paint loop at this.fps rate
         *
         * @method beginPainting()
         */
        beginPainting: function() {
            var self = this;
            self.repaintNow = true;
            var interval = 1000 / this.fps;
            var lastRepaintTime = 0;
            var animate = function(now) {
                self.checksize();
                var delta = now - lastRepaintTime;
                if (delta > interval && self.repaintNow) {
                    lastRepaintTime = now - (delta % interval);
                    self.paintNow();
                }
                requestAnimationFrame(animate);
            };
            requestAnimationFrame(animate);
        },

        /**
         *                                                                      .
         *                                                                      .
         * check to see if my size has changed, if so notify myself
         *
         * @method checksize()
         */
        checksize: function() {
            var sizeNow = this.getBoundingClientRect();
            if (sizeNow.width !== this.size.width || sizeNow.height !== this.size.height) {
                this.sizeChangedNotification();
            }
        },

        /**
         *                                                                      .
         *                                                                      .
         * my size has changed, lets resize
         *
         * @method sizeChangedNotification()
         */
        sizeChangedNotification: function() {
            this.resize();
        },

        /**
         *                                                                      .
         *                                                                      .
         * because HTMLCanvasElement doesn't obey normal HTML5 resize semantics, we need to update canvas and buffer sizes when our size changes
         *
         * @method resize()
         */
        resize: function() {
            this.size = this.getBoundingClientRect();

            this.canvas.width = this.clientWidth;
            this.buffer.width = this.clientWidth;

            this.canvas.height = this.clientHeight;
            this.buffer.height = this.clientHeight;

            this.origin = this.g.point.create(this.size.left, this.size.top);
            this.bounds = this.g.rectangle.create(0, 0, this.size.width, this.size.height);
            //setTimeout(function() {
            var comp = this.getComponent();
            if (comp) {
                comp.setBounds(this.bounds);
            }
            this.resizeNotification();
            this.paintNow();
            //});
        },

        /**
         *                                                                      .
         *                                                                      .
         * my size has changed, lets resize
         *
         * @method sizeChangedNotification()
         */
        resizeNotification: function() {
            //to be overridden
        },

        /**
         *                                                                      .
         *                                                                      .
         * my bounds with origin 0,0 and width and height set according to [getBoundingClientRect](https://developer.mozilla.org/en-US/docs/Web/API/Element.getBoundingClientRect)
         *
         * @method getBounds()
         */
        getBounds: function() {
            return this.bounds;
        },

        /**
         *                                                                      .
         *                                                                      .
         * force a safe paint right now and then flush the buffer to the screen
         *
         * @method paintNow()
         */
        paintNow: function() {
            var gc = this.ctx;
            try {
                gc.save();
                gc.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.paint(gc);
            } finally {
                gc.restore();
            }
            this.flushBuffer();
            this.repaintNow = false;
        },

        /**
         *                                                                      .
         *                                                                      .
         * render the buffered drawing to the screen
         *
         * @method flushBuffer()
         */
        flushBuffer: function() {
            if (this.buffer.width > 0 && this.buffer.height > 0) {
                this.canvasCTX.drawImage(this.buffer, 0, 0);
            }
        },

        /**
         *                                                                      .
         *                                                                      .
         * this is the entry point to the view-heirarchy sub-structure painting, passing in the graphics context gc
         *
         * @method paint(gc)
         */
        paint: function(gc) {
            var comp = this.getComponent();
            if (comp) {
                comp._paint(gc);
            }
        },

        /**
         *                                                                      .
         *                                                                      .
         * handle the mouse move event
         *
         * @method finmousemove(e)
         */

        finmousemove: function(e) {
            var o = this.getOrigin();
            if (!this.dragging && this.mousedown) {
                this.dragging = true;
                this.dispatchEvent(new CustomEvent('fin-dragstart', {
                    detail: {
                        mouse: this.mouseLocation,
                        keys: this.currentKeys
                    }
                }));
                this.dragstart = this.g.point.create(this.mouseLocation.x, this.mouseLocation.y);
            }
            this.mouseLocation = this.g.point.create((e.x || e.layerX) - o.x, (e.y || e.layerY) - o.y);
            if (this.dragging) {
                this.dispatchEvent(new CustomEvent('fin-drag', {
                    detail: {
                        mouse: this.mouseLocation,
                        dragstart: this.dragstart,
                        keys: this.currentKeys
                    }
                }));
            }
            if (this.bounds.contains(this.mouseLocation)) {
                this.dispatchEvent(new CustomEvent('fin-mousemove', {
                    detail: {
                        mouse: this.mouseLocation,
                        keys: this.currentKeys
                    }
                }));
            }
        },

        /**
         *                                                                      .
         *                                                                      .
         * handle the mouse down event
         *
         * @method finmousedown(e)
         */
        finmousedown: function(e) {

            this.mouseLocation = this.g.point.create((e.offsetX || e.layerX), (e.offsetY || e.layerY));
            this.mousedown = true;

            this.dispatchEvent(new CustomEvent('fin-mousedown', {
                detail: {
                    mouse: this.g.point.create((e.offsetX || e.layerX), (e.offsetY || e.layerY)),
                    keys: this.currentKeys
                }
            }));
            this.takeFocus();

        },

        /**
         *                                                                      .
         *                                                                      .
         * handle the mouse up event
         *
         * @method finmouseup(e)
         */
        finmouseup: function() {
            if (this.dragging) {
                this.dispatchEvent(new CustomEvent('fin-dragend', {
                    detail: {
                        mouse: this.mouseLocation,
                        dragstart: this.dragstart,
                        keys: this.currentKeys
                    }
                }));
                this.dragging = false;
            }
            this.mousedown = false;
            this.mouseLocation = this.g.point.create(-1, -1);
            this.dispatchEvent(new CustomEvent('fin-mouseup', {
                detail: {
                    mouse: this.mouseLocation,
                    keys: this.currentKeys
                }
            }));
        },

        /**
         *                                                                      .
         *                                                                      .
         * handle the mouse out event
         *
         * @method finmouseout(e)
         */
        finmouseout: function() {
            if (!this.mousedown) {
                this.mouseLocation = this.g.point.create(-1, -1);
            }
            this.dispatchEvent(new CustomEvent('fin-mouseout', {
                detail: {
                    mouse: this.mouseLocation,
                    keys: this.currentKeys
                }
            }));
        },

        /**
         *                                                                      .
         *                                                                      .
         * handle the mouse click event
         *
         * @method finclick(e)
         */
        finclick: function(e) {
            this.mouseLocation = this.g.point.create((e.offsetX || e.layerX), (e.offsetY || e.layerY));
            this.dispatchEvent(new CustomEvent('fin-click', {
                detail: {
                    mouse: this.mouseLocation,
                    keys: this.currentKeys
                }
            }));
        },

        /**
         *                                                                      .
         *                                                                      .
         * handle the mouse double click event
         *
         * @method findblclick(e)
         */
        findblclick: function(e) {
            this.mouseLocation = this.g.point.create((e.offsetX || e.layerX), (e.offsetY || e.layerY));
            this.dispatchEvent(new CustomEvent('fin-dblclick', {
                detail: {
                    mouse: this.mouseLocation,
                    keys: this.currentKeys
                }
            }));
        },

        /**
         *                                                                      .
         *                                                                      .
         * handle the keydown event
         *
         * @method finkeydown(e)
         */
        finkeydown: function(e) {
            if (!this.hasFocus()) {
                return;
            }
            //e.preventDefault();
            var keyChar = e.shiftKey ? charMap[e.keyCode][1] : charMap[e.keyCode][0];
            if (e.repeat) {
                if (this.repeatKey === keyChar) {
                    this.repeatKeyCount++;
                } else {
                    this.repeatKey = keyChar;
                    this.repeatKeyStartTime = Date.now();
                }
            } else {
                this.repeatKey = null;
                this.repeatKeyCount = 0;
                this.repeatKeyStartTime = 0;
            }
            if (this.currentKeys.indexOf(keyChar) === -1) {
                this.currentKeys.push(keyChar);
            }
            this.dispatchEvent(new CustomEvent('fin-keydown', {
                detail: {
                    alt: e.altKey,
                    ctrl: e.ctrlKey,
                    char: keyChar,
                    code: e.charCode,
                    key: e.keyCode,
                    meta: e.metaKey,
                    repeatCount: this.repeatKeyCount,
                    repeatStartTime: this.repeatKeyStartTime,
                    shift: e.shiftKey,
                    identifier: e.keyIdentifier
                }
            }));
        },

        /**
         *                                                                      .
         *                                                                      .
         * handle the keyup event
         *
         * @method finkeyup(e)
         */
        finkeyup: function(e) {
            if (!this.hasFocus()) {
                return;
            }
            var keyChar = e.shiftKey ? charMap[e.keyCode][1] : charMap[e.keyCode][0];
            this.repeatKeyCount = 0;
            this.repeatKey = null;
            this.repeatKeyStartTime = 0;
            this.currentKeys.splice(this.currentKeys.indexOf(keyChar), 1);
            this.dispatchEvent(new CustomEvent('fin-keyup', {
                detail: {
                    alt: e.altKey,
                    ctrl: e.ctrlKey,
                    char: keyChar,
                    code: e.charCode,
                    key: e.keyCode,
                    meta: e.metaKey,
                    repeat: e.repeat,
                    shift: e.shiftKey,
                    identifier: e.keyIdentifier
                }
            }));
        },

        /**
         *                                                                      .
         *                                                                      .
         * handle the focusgained event
         *
         * @method finfocusgained(e)
         */
        finfocusgained: function(e) {
            this.focused = true;
            this.dispatchEvent(new CustomEvent('fin-focus-gained', {
                detail: {
                    e: e
                }
            }));
        },

        /**
         *                                                                      .
         *                                                                      .
         * handle the focuslost event
         *
         * @method finfocuslost(e)
         */
        finfocuslost: function(e) {
            this.focused = false;
            this.dispatchEvent(new CustomEvent('fin-focus-lost', {
                detail: {
                    e: e
                }
            }));
        },

        /**
         *                                                                      .
         *                                                                      .
         * tickle the repaint flag to on
         *
         * @method repaint()
         */
        repaint: function() {
            this.repaintNow = true;
        },

        /**
         *                                                                      .
         *                                                                      .
         * getter accessor for the mouseLocation field
         *
         * @method getMouseLocation()
         */
        getMouseLocation: function() {
            return this.mouseLocation;
        },

        /**
         *                                                                      .
         *                                                                      .
         * getter accessor for the origin field
         *
         * @method getOrigin()
         */
        getOrigin: function() {
            return this.origin;
        },

        /**
         *                                                                      .
         *                                                                      .
         * answer if I have focus
         *
         * @method hasFocus()
         */
        hasFocus: function() {
            return this.focused;
        },

        /**
         *                                                                      .
         *                                                                      .
         * try to take global input focus
         *
         * @method takeFocus()
         */
        takeFocus: function() {
            var self = this;
            if (document.activeElement !== this.focuser) {
                setTimeout(function() {
                    self.focuser.focus();
                }, 10);
            }
        }

    });

})(); /* jslint ignore:line */

  </script>
</polymer-element>

<polymer-element name="fin-vampire-bar" attributes="" assetpath="../fin-vampire-bar/">
  <template>
    <style>
    .scroll-bar {
      width: 15px;
      position: absolute;
      top:0;
      bottom:0;
      background-color: lightgrey;
    }
    .scroll-bar-gutter {
      position: absolute;
      top: 0%;
      bottom: 0%;
      right: 0%;
      left: 0%;
      margin-top: 15px;
      margin-bottom: 35px;
    }
    .scroll-bar.horizontal {
      height: 15px;
      width: 100%;
      position: absolute;
      left:0;
      right: 100%;
      top:100%;
    }

    .horizontal .scroll-bar-gutter {
      position: absolute;
      top: 0%;
      bottom: 0%;
      right: 0%;
      left: 0%;
      margin-top: 0px;
      margin-bottom: 0px;
      margin-left: 15px;
      margin-right: 35px;
    }

    .scroll-bar-up{
      position: absolute;
      top: 0;
      left: 0;
      width: 15px;
      height: 15px;
      background-color: darkgrey;
    }

    .scroll-bar.horizontal .scroll-bar-up{
      position: absolute;
      top: 0;
      right: 0;
      left: auto;
      width: 15px;
      height: 15px;
      background-color: darkgrey;
    }

    .scroll-bar-thumb {
      background-color: gray;
      width: 15px;
      height: 20px;
      top: 0;
      left: 0px;
      position: absolute;
    }
/*    .scroll-bar-thumb:mousedown {

    }*/

    .scroll-bar.horizontal .scroll-bar-thumb {
      height: 15px;
      width: 20px;
      left: 0px;
      top: 0;
      position: absolute;
    }

    .scroll-bar-down{
      position: absolute;
      right: 0;
      bottom: 0;
      width: 15px;
      height: 15px;
      background-color: darkgrey;
    }
    .scroll-bar.horizontal .scroll-bar-down{
      position: absolute;
      left: 0;
      width: 15px;
      height: 15px;
      background-color: darkgrey;
    }

    </style>
    <div class="scroll-bar">
      <div class="scroll-bar-up"></div>
      <div class="scroll-bar-gutter">
        <div class="scroll-bar-thumb" draggable="false"></div>
      </div>
      <div class="scroll-bar-down"></div>
    </div>
  </template>

  <script>

'use strict';

(function() {

    // # scroll-bar.js
    //
    // This module defines a custom `<scroll-bar>` element and attaches it to the
    // document.
    //


    var //templateHolder = document.createElement('div'),
    //SCROLL_BAR_BUTTON_SIZE = 15,
        throttle = function(func, wait, options) {
        var context, args, result;
        var timeout = null;
        var previous = 0;
        if (!options) {
            options = {};
        }
        var later = function() {
            previous = options.leading === false ? 0 : Date.now();
            timeout = null;
            result = func.apply(context, args);
            if (!timeout) {
                context = args = null;
            }
        };
        return function() {
            var now = Date.now();
            if (!previous && options.leading === false) {
                previous = now;
            }
            var remaining = wait - (now - previous);
            context = this;
            args = arguments;
            if (remaining <= 0 || remaining > wait) {
                clearTimeout(timeout);
                timeout = null;
                previous = now;
                result = func.apply(context, args);
                if (!timeout) {
                    context = args = null;
                }
            } else if (!timeout && options.trailing !== false) {
                timeout = setTimeout(later, remaining);
            }
            return result;
        };
    };

    //templateHolder.innerHTML = require('./templates.js').scrollbar();



    //ScrollBar.prototype = Object.create(window.HTMLElement.prototype);

    Polymer('fin-vampire-bar', { /* jshint ignore:line  */

        setRangeAdapter: function(rangeAdapter) {

            var that = this;

            that.rangeAdapter = rangeAdapter;
            if (that.thumb) {
                that.thumb.rangeAdapter = rangeAdapter;
            }

            rangeAdapter.valueChanged = function(change) {
                var value = rangeAdapter.getValue();
                if (value) {
                    try {
                        that.supressUpdates = true;
                        that.moveToPercent(value);
                    } finally {
                        that.supressUpdates = false;
                    }
                }
            };

        },

        offset : 0,

        // the createdCallback method will be called by the native code
        attached: function() {

            var that = this;




            // this.this.shadowRoot = this.shadowRoot;

            // get the actionable child elements
            this.bar = this.shadowRoot.querySelector('.scroll-bar');
            this.thumb = this.shadowRoot.querySelector('.scroll-bar-thumb');
            this.gutter = this.shadowRoot.querySelector('.scroll-bar-gutter');

            this.configureOrientation();

            //var bounds = that.bounds = that.getBoundingClientRect();
            that.isScrolling = false;

            that.attachThumbMouseDown()
                .attachThumbMouseMove()
                .attachThumbMouseUp();
        }, // end attaached


        throttledWheelEvent: throttle(function(event) {

            var that = this;

            var directionXY = that.orientation.toUpperCase(),
                styleProperty = directionXY === 'Y' ? 'top' : 'left',
                rangeStop = that.rangeAdapter.rangeStop(),
                currentPercent = ((that.thumb.style && that.thumb.style[styleProperty]) && parseFloat(that.thumb.style[styleProperty])) || 0,
                direction = event['delta' + directionXY] > 0 ? 1 : -1,
                currentPercentAsRows = Math.round(that.rangeAdapter.rangeStop() * currentPercent),
                oneMoreRow = Math.round(currentPercentAsRows + (1 * direction)),
                ranged = oneMoreRow / rangeStop / 100;

            ranged = ranged > 1 ? 1 : ranged;
            ranged = ranged < 0 ? 0 : ranged;

            that.rangeAdapter.setValue(ranged);

        }, 30),

        attachWheelEvent: function() {
            var that = this;

            document.addEventListener('wheel', function(event) {
                // dont pull on the page at all
                event.preventDefault();
                that.throttledWheelEvent(event);
            });

            return that;
        },

        attachThumbMouseDown: function() {
            var that = this;

            that.thumb.addEventListener('mousedown', function(event) {
                that.isScrolling = true;
                var offset = (typeof event['offset' + that.orientation.toUpperCase()] === 'undefined') ? 'layer' : 'offset';
                that.offset = event[offset + that.orientation.toUpperCase()];
            });

            return that;
        },

        attachThumbMouseMove: function() {
            var that = this;

            document.addEventListener('mousemove', function(event) {
                if (that.isScrolling) {

                    that.moveThumb(event['page' + that.orientation.toUpperCase()]);
                }
            });

            return that;
        },

        attachThumbMouseUp: function() {
            var that = this;
            document.addEventListener('mouseup', function() {
                if (that.isScrolling) {
                    that.isScrolling = false;
                }
            });

            return that;
        },

        moveThumb: function(pageLocation) {
            var that = this,
                direction = this.orientation === 'y' ? 'top' : 'left',
                //percent,
                maxScroll = that.getMaxScroll(),
                distanceFromEdge = that.gutter.getBoundingClientRect(),
                offBy = pageLocation - distanceFromEdge[direction] - that.offset;

            offBy = offBy < 0 ? 0 : offBy;
            offBy = offBy / maxScroll;
            offBy = offBy > 1 ? 1 : offBy;
            offBy = offBy * 100;

            that.thumb.style[direction] = offBy + '%';

            if (that.rangeAdapter) {
                if (that.supressUpdates) {
                    return;
                }
                that.rangeAdapter.setValue(offBy / 100);
            }
        }, //end movethumb value

        moveToPercent: function(percent) {
            var that = this;

            if (!that.isScrolling) {
                that.moveThumb(percent * this.getMaxScroll());
            }
        },


        setValueUpdatedCallback: function(callback) {
            this.valueUpdatedCallback = callback;

        },


        setOrientation: function(orientation) {
            this.orientation = orientation;

        },

        getMaxScroll: function() {
            var direction = this.orientation === 'y' ? 'clientHeight' : 'clientWidth';
            return this.gutter[direction];

        },


        configureOrientation: function() {
            var orientation = 'y';

            if ('horizontal' in this.attributes) {
                orientation = 'x';
                this.bar.classList.add('horizontal');
            }

            this.setOrientation(orientation);
        },

        tickle: function() {
            this.rangeAdapter.setValue(this.lastPercent);
        },

        lastPercent: 0.0,

        createRangeAdapter: function(subject, userConfig) {
            var config = userConfig || {
                    step: 1,
                    page: 40,
                    rangeStart: 0,
                    rangeStop: 100
                },
                that = {};

            // this is the 'cached' value that is listenable
            that.valueObj = {
                value: null
            };

            // apparent Polymer object.observe polyfill breaking change...
            // Object.observe(subject, function() {
            //     that.subjectChanged();
            // });

            that.subjectChanged = function() {
                that.valueObj.value = that.computeNormalizedValue();
                that.valueChanged();
            };

            // that.grid = function(value) {
            //     if (value === undefined) {
            //         return grid;
            //     }
            //     grid = value;
            // };

            that.rangeStart = function(value) {
                if (value === undefined) {
                    return config.rangeStart;
                }
            };

            that.rangeStop = function(value) {
                if (value === undefined) {
                    return config.rangeStop;
                }
            };

            that.page = function(value) {
                if (value === undefined) {
                    return config.page;
                }
            };

            // @param value is a number
            that.setValue = function(newValue) {
                if (typeof newValue !== 'number') {
                    return;
                }
                var deNormalized = Math.floor((newValue * (config.rangeStop - config.rangeStart)) + config.rangeStart);
                subject.setValue(deNormalized);
                that.valueObj.value = newValue;
                that.valueChanged();
            };
            that.computeNormalizedValue = function() {
                var value = (subject.getValue() - config.rangeStart) / (config.rangeStop - config.rangeStart);
                return value;
            };

            that.getValue = function() {
                return that.valueObj.value;
            };

            that.valueChanged = function(){};


            return that;
        }

    });

})();

  </script>
</polymer-element>
<polymer-element name="fin-canvas-component" class="fin-canvas-component" attributes="layoutProperties" assetpath="../fin-canvas/">
  <template></template>
  <script>

'use strict';

(function() {

    Polymer('fin-canvas-component', { /* jshint ignore:line */
        ready: function() {
            this.readyInit();
        },
        readyInit: function() {
            this.g = document.createElement('fin-rectangle');
            this.parent = null;
            this.bounds = this.g.rectangle.create(0, 0, 0, 0);
            this.color = this.color || 'black';
            this.backgroundColor = null;
            this.layoutProperties = this.layoutProperties || [0, 0, 1, 0, 1, 0, 0, 0];
            if (typeof this.layoutProperties === 'string') {
                this.layoutProperties = JSON.parse(this.layoutProperties);
            }
        },
        setBounds: function(rectangle) {
            this.bounds = rectangle;
        },
        getBounds: function() {
            return this.bounds;
        },
        _paint: function(gc) {
            try {
                gc.save();
                gc.translate(this.bounds.left(), this.bounds.top());
                // bug in mozilla canvas of mac workaround
                // don't use cliping
                // gc.rect(0, 0, bounds.width(), bounds.height());
                // gc.clip();
                var bgColor = this.getBackgroundColor();
                if (bgColor) {
                    var rect = this.getBounds();
                    gc.beginPath();
                    gc.fillStyle = bgColor;
                    gc.fillRect(0, 0, rect.width(), rect.height());
                    gc.stroke();
                }
                this.paint(gc);
            } finally {
                gc.restore();
            }
        },
        paint: function( /* gc */ ) {},
        getBackgroundColor: function() {
            return this.backgroundColor;
        },
        setBackgroundColor: function(colorValue) {
            this.backgroundColor = colorValue;
        },
        repaint: function() {
            if (this.parent) {
                this.parent.repaint();
            }
        },
        setParent: function(newParent) {
            this.parent = newParent;
        },
        getLayoutProperties: function() {
            return this.layoutProperties;
        },
        setLayoutProperties: function(properties) {
            this.layoutProperties = properties;
        },
        getComponent: function() {
            var comp = this.children[0];
            return comp;
        }
    });

})();

  </script>
</polymer-element>
<polymer-element name="fin-hypergrid-renderer" extends="fin-canvas-component" assetpath="">
  <template></template>
  <script>

//HypergridRenderer is the canvas enabled top level sub component that handles the renderering of the Grid.
// * It relies on two other external subprojects
//  * of-canvas: a wrapper to provide a simpler interface to the HTML5 canvas component
//  * rectangles: a small library providing Point and Rectangle objects

//The HypergridRenderer is in a unique position to provide critical functionality to the OFGrid in a hightly performant manner.  Because it MUST iterate over all the visible cells it can store various bits of information that can be encapsulated as a service for consumption by the OFGrid component.

//this object is basically four main functions
// * render fixed row headers
// * render fixed col headers
// * render main data cells
// * render grid lines

'use strict';
(function() {

    var constants;

    // we need a reusable cellconfig object
    var config = {};
    var cellConfig = function(x, y, value, fgColor, bgColor, fgSelColor, bgSelColor, font, isSelected, halign) {
        config.x = x;
        config.y = y;
        config.value = value;
        config.fgColor = fgColor;
        config.bgColor = constants.backgroundColor === bgColor ? null : bgColor;
        config.fgSelColor = fgSelColor;
        config.bgSelColor = bgSelColor;
        config.font = font;
        config.isSelected = isSelected;
        config.halign = halign || 'center';
        return config;
    };

    Polymer('fin-hypergrid-renderer',{ /* jslint ignore:line */

        ready: function() {
          this.readyInit();
          if (!constants) {
              constants = document.createElement('fin-hypergrid-constants').values;
          }
          this.renderedColWidths = [0];
          this.renderedRowHeights = [0];
          this.renderedCols = [];
          this.renderedRows = [];
          this.setBackgroundColor(constants.gridBackgroundColor);
        },

        getGrid: function() {
            return this.hypergrid;
        },

        setGrid: function(grid) {
            this.hypergrid = grid;
        },
        //This is the entry point from OFCanvas.  Notify the OFGrid everytime we've repainted.
        paint: function(gc) {
            if (!this.hypergrid) {
              return;
            }
            this.renderGrid(gc);
            this.getGrid().gridRenderedNotification();
        },

        //Answer how many rows we rendered
        getViewableRows: function() {
            return this.renderedRows.length;
        },

        //Answer how many columns we just rendered
        getViewableCols: function() {
            return this.renderedCols.length;
        },

        //Answer the pixel bounds of specific data cell. It must have just been rendered
        getBoundsOfCell: function(cell) {
            var ox = this.renderedColWidths[cell.x],
                oy = this.renderedRowHeights[cell.y],
                cx = this.renderedColWidths[cell.x + 1],
                cy = this.renderedRowHeights[cell.y + 1],
                ex = cx - ox,
                ey = cy - oy;

            var bounds = this.g.rectangle.create(ox, oy, ex, ey);

            return bounds;
        },

        //Answer specific data cell coordinates given mouse coordinates in pixels.
        getCellFromMousePoint: function(point) {

            var width = 0;
            var height = 0;
            var x, y;
            var c, r;
            var previous = 0;
            for (c = 1; c < this.renderedColWidths.length; c++) {
                width = this.renderedColWidths[c];
                if (point.x < width) {
                    x = Math.max(0, point.x - previous - 2);
                    break;
                }
                previous = width;
            }
            c--;
            previous = 0;
            for (r = 1; r < this.renderedRowHeights.length; r++) {
                height = this.renderedRowHeights[r];
                if (point.y < height) {
                    y = Math.max(0, point.y - previous - 2);
                    break;
                }
                previous = height;
            }
            r--;
            if (point.x < 0) {
                c = -1;
            }
            if (point.y < 0) {
                r = -1;
            }

            return {
                cell: this.g.point.create(c, r),
                location: this.g.point.create(x, y)
            };
        },

        //Answer if a column is visible, must be fully visible
        isColVisible: function(c) {
            var isVisible = this.renderedCols.indexOf(c) !== -1;
            return isVisible;
        },

        //Answer if a row is visible, must be fully visible
        isRowVisible: function(r) {
            var isVisible = this.renderedRows.indexOf(r) !== -1;
            return isVisible;
        },

        //Answer if a data cell is selected.
        isSelected: function(x, y) {
            return this.getGrid().isSelected(x, y);
        },

        //This is the main forking of the renderering task.  GC is a graphics context.
        //<br>[CanvasRenderingContext2D](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D)
        renderGrid: function(gc) {
            var offsetX = this.getBehavior().getFixedColsWidth();
            var offsetY = this.getBehavior().getFixedRowsHeight();

            this.paintCells(gc, offsetX, offsetY);
            this.paintHeaders(gc, 0, 0);
            this.paintGridlines(gc, offsetX, offsetY);
        },

        //We opted to not paint borders for each cell as that was extremely expensive.  Instead we draw gridlines here.  Also we record the widths and heights for later.
        paintGridlines: function(gc, offsetX, offsetY) {
            var behavior = this.getBehavior();
            var lineColor = constants.lineColor; //draw horizontal grid line

            var numCols = behavior.getColCount();
            var numRows = behavior.getRowCount();
            var numFixedCols = behavior.getFixedColCount();
            var numFixedRows = behavior.getFixedRowCount();

            var fixedColsWidth = behavior.getFixedColsWidth();
            var fixedRowsHeight = behavior.getFixedRowsHeight();

            this.renderedColWidths = [0];
            this.renderedRowHeights = [0];
            this.renderedCols = [];
            this.renderedRows = [];

            var scrollTop = this.getScrollTop();
            var scrollLeft = this.getScrollLeft();
            var viewWidth = this.getBounds().width();
            var viewHeight = this.getBounds().height();


            gc.strokeStyle = lineColor;
            gc.lineWidth = 1;
            var c, r, x, y, width, height;

            //fixedrow horiontal grid lines
            gc.beginPath();
            gc.moveTo(0, 0);
            y = 0;
            for (r = 0; r < numFixedRows; r++) {
                height = this.getFixedRowHeight(r);
                y = y + height;
                this.renderedRowHeights.push(y);
                gc.moveTo(fixedColsWidth, y);
                gc.lineTo(viewWidth, y);
                gc.stroke();
            }

            //fixedcol vertical grid lines
            gc.beginPath();
            gc.moveTo(0, 0);
            x = 0;
            for (c = 0; c < numFixedCols; c++) {
                width = this.getFixedColWidth(c);
                x = x + width;
                this.renderedColWidths.push(x);
                gc.moveTo(x, fixedRowsHeight);
                gc.lineTo(x, viewHeight);
                gc.stroke();
            }

            //main area vertical grid lines
            gc.beginPath();
            gc.moveTo(0, 0);
            x = offsetX;
            for (c = 0; c < numCols; c++) {
                width = this.getColWidth(c + scrollLeft);

                this.renderedCols.push(c + scrollLeft);

                if (x > viewWidth || numCols < scrollLeft + c) {
                    this.renderedCols.length = Math.max(0, this.renderedCols.length - 2);
                    break;
                }
                gc.moveTo(x, 0);
                gc.lineTo(x, viewHeight);
                gc.stroke();
                x = x + width;
                this.renderedColWidths.push(x);
            }

            //main area horizontal grid lines
            gc.beginPath();
            gc.moveTo(0, 0);
            y = offsetY;
            for (r = 0; r < numRows; r++) {
                height = this.getRowHeight(r + scrollTop);

                this.renderedRows.push(r + scrollTop);

                if (y > viewHeight || numRows < scrollTop + r) {
                    this.renderedRows.length = Math.max(0, this.renderedRows.length - 2);
                    break;
                }
                gc.moveTo(0, y);
                gc.lineTo(viewWidth, y);
                gc.stroke();
                y = y + height;
                this.renderedRowHeights.push(y);
            }
        },

        paintHeaders: function(ctx, offsetX, offsetY) {

            this.paintFixedRows(
                ctx,
                offsetX + this.getBehavior().getFixedColsWidth(),
                offsetY,
                this.getBehavior().getColCount(),
                this.getBehavior().getFixedRowCount());

            this.paintFixedCols(
                ctx,
                offsetX,
                offsetY + this.getBehavior().getFixedRowsHeight(),
                this.getBehavior().getFixedColCount(),
                this.getBehavior().getRowCount());

            this.paintTopLeft(ctx, 0, 0);
        },

        //Renderer the fixed header rows along the top
        paintFixedRows: function(ctx, offsetX, offsetY, numCols, numRows) {
            var behavior = this.getBehavior();
            var x = offsetX;
            var scrollLeft = this.getScrollLeft();
            var font = constants.defaultFont;
            var fgColor = constants.foregroundColor;
            var bgColor = constants.backgroundColor;
            var fgSelColor = constants.fixedRowFGSelColor;
            var bgSelColor = constants.fixedRowBGSelColor;
            var fixedRowBGColor = constants.fixedRowBGColor;
            var halign = constants.fixedRowAlign;
            var cellProvider = this.getGrid().getCellProvider();
            var viewWidth = this.getBounds().width();
            var viewHeight = this.getBehavior().getFixedRowsHeight();
            for (var c = 0; c < numCols; c++) {
                var width = this.getColWidth(c + scrollLeft);
                if (x > viewWidth || numCols <= scrollLeft + c) {
                    return;
                }
                var isSelected = this.isFixedRowCellSelected(c + scrollLeft);
                var y = offsetY;

                ctx.fillStyle = fixedRowBGColor;
                ctx.fillRect(x, y, x + width, viewHeight - y);

                for (var r = 0; r < numRows; r++) {

                    var height = this.getFixedRowHeight(r);
                    var value = behavior.getFixedRowValue(c + scrollLeft, r);

                    var cell = cellProvider.getFixedRowCell(cellConfig(c + scrollLeft, r, value, fgColor, bgColor, fgSelColor, bgSelColor, font, isSelected, halign));
                    cell.paint(ctx, x, y, width, height);
                    y = y + height;
                }
                x = x + width;
            }
        },

        //Render the fixed columns along the left side
        paintFixedCols: function(ctx, offsetX, offsetY, numCols, numRows) {
            var behavior = this.getBehavior();
            var x = offsetX;
            var font = constants.defaultFont;
            var fgColor = constants.foregroundColor;
            var bgColor = constants.backgroundColor;
            var fixedColBGColor = constants.fixedColBGColor;
            var fgSelColor = constants.fixedColFGSelColor;
            var bgSelColor = constants.fixedColBGSelColor;
            var halign = constants.fixedColAlign;
            var scrollTop = this.getScrollTop();
            var cellProvider = this.getGrid().getCellProvider();
            var viewHeight = this.getBounds().height();

            for (var c = 0; c < numCols; c++) {
                var width = this.getFixedColWidth(c);
                var y = offsetY;

                ctx.fillStyle = fixedColBGColor;
                ctx.fillRect(x, y, width, viewHeight - y);

                for (var r = 0; r < numRows; r++) {
                    var height = this.getRowHeight(r + scrollTop);
                    var isSelected = this.isFixedColCellSelected(r + scrollTop);
                    if (y > viewHeight || numRows <= scrollTop + r) {
                        break;
                    }
                    var value = behavior.getFixedColValue(c, r + scrollTop);
                    var cell = cellProvider.getFixedColCell(cellConfig(c, r + scrollTop, value, fgColor, bgColor, fgSelColor, bgSelColor, font, isSelected, halign));
                    cell.paint(ctx, x, y, width, height);
                    y = y + height;
                }
                x = x + width;
            }
        },

        //Render the main cells.  We snapshot the context to insure against its polution.
        //<br>TODO:save/restore should be a general wrapper that we use here and for the other renderer, fixed rows/cols and gridlines as well.
        paintCells: function(ctx, offsetX, offsetY) {
            try {
                ctx.save();
                this._paintCells(ctx, offsetX, offsetY);
            } finally {
                ctx.restore();
            }
        },

        _paintCells: function(ctx, offsetX, offsetY) {
            var behavior = this.getBehavior();
            var numCols = behavior.getColCount();
            var numRows = behavior.getRowCount();
            var x = offsetX;
            var startY = offsetY;
            var scrollTop = this.getScrollTop();
            var scrollLeft = this.getScrollLeft();
            var cellProvider = this.getGrid().getCellProvider();
            var font = constants.defaultFont;
            var fgColor = constants.foregroundColor;
            var bgColor = constants.backgroundColor;
            var fgSelColor = constants.foregroundSelColor;
            var bgSelColor = constants.backgroundSelColor;
            var viewWidth = this.getBounds().width();
            var viewHeight = this.getBounds().height();

            for (var c = 0; c < numCols; c++) {
                var width = this.getColWidth(c + scrollLeft);
                if (x > viewWidth || numCols <= scrollLeft + c) {
                    return;
                }

                var y = startY;
                var colAlign = behavior.getColAlignment(c + scrollLeft);
                //fill background
                ctx.fillStyle = bgColor;
                ctx.fillRect(x, y, x + width, viewHeight - y);

                for (var r = 0; r < numRows; r++) {
                    var isSelected = this.isSelected(c + scrollLeft, r + scrollTop);
                    var height = this.getRowHeight(r + scrollTop);
                    if (y > viewHeight || numRows <= scrollTop + r) {
                        break;
                    }

                    var value = behavior.getValue(c + scrollLeft, r + scrollTop);
                    // if (!value && value !== 0) { // edge condition if were scrolled all the way to the end
                    //     break;
                    // }
                    var cell = cellProvider.getCell(cellConfig(c + scrollLeft, r + scrollTop, value, fgColor, bgColor, fgSelColor, bgSelColor, font, isSelected, colAlign));

                    cell.paint(ctx, x, y, width, height);

                    y = y + height;
                }

                x = x + width;
            }
        },

        //This is the empty top left corner of the grid.
        paintTopLeft: function(ctx, offsetX, offsetY) {
            ctx.beginPath();
            //var border = this.getGrid().provider.require('borderprovider').getBorder('simple');
            var fixedRowHeight = this.getBehavior().getFixedRowsHeight();
            var fixedColWidth = this.getBehavior().getFixedColsWidth();
            ctx.fillStyle = constants.topLeftHeaderBGColor;
            ctx.fillRect(offsetX, offsetY, fixedColWidth, fixedRowHeight);
            //border.paint(ctx, offsetX, offsetY, fixedColWidth, fixedRowHeight, constants.lineColor);
            ctx.stroke();
        },

        isFixedRowCellSelected: function(col) {
            return this.getGrid().isFixedRowCellSelected(col);
        },

        isFixedColCellSelected: function(row) {
            return this.getGrid().isFixedColCellSelected(row);
        },

        getScrollTop: function() {
            var st = this.getGrid().getVScrollValue();
            return st;
        },

        getScrollLeft: function() {
            var st = this.getGrid().getHScrollValue();
            return st;
        },

        getBehavior: function() {
            return this.getGrid().getBehavior();
        },

        getConstants: function() {
            return this.getGrid().constants;
        },

        getFixedRowHeight: function(rowIndex) {
            var height = this.getBehavior().getFixedRowHeight(rowIndex);
            return height;
        },

        getRowHeight: function(rowIndex) {
            var height = this.getBehavior().getRowHeight(rowIndex);
            return height;
        },

        getColWidth: function(colIndex) {
            var width = this.getBehavior().getColWidth(colIndex);
            return width;
        },

        getFixedColWidth: function(rowIndex) {
            var height = this.getBehavior().getFixedColWidth(rowIndex);
            return height;
        }

    });

})(); /* jslint ignore:line */

  </script>
</polymer-element>

<polymer-element name="fin-hypergrid-selection-model" assetpath="">
  <template>
  </template>
  <script>

'use strict';

(function() {

    //We represent selections as a list of rectangles because large areas can be represented and tested against quickly with a minimal amount of memory usage. Also we need to maintain the selection rectangles flattened counter parts so we can test for single dimension contains.  This is how we know to highlight the fixed regions on the edges of the grid.

    Polymer('fin-hypergrid-selection-model',{ /* jslint ignore:line */
        ready: function() {

            this.rectangles = document.createElement('fin-rectangle');
            this.selections = [];
            this.flattenedX = [];
            this.flattenedY = [];
        },
        getGrid: function() {
            return null;
        },
        //select a rectangle
        select: function(ox, oy, ex, ey) {

            //this is very hacky, we swap the origin and extent if the extents are negative
            //<br>TODO:fix rectangle package to implement high performant contains with negative extents

            var newSelection = this.rectangles.rectangle.create(ox, oy, ex, ey);
            this.selections.push(newSelection);
            this.flattenedX.push(newSelection.flattenXAt(0));
            this.flattenedY.push(newSelection.flattenYAt(0));
        },

        //remove the last selection that was created
        clearMostRecentSelection: function() {
            this.selections.length = Math.max(0, this.selections.length - 1);
            this.flattenedX.length = Math.max(0, this.flattenedX.length - 1);
            this.flattenedY.length = Math.max(0, this.flattenedY.length - 1);
        },

        getSelections: function() {
            return this.selections;
        },

        hasSelections: function() {
            return this.selections.length !== 0;
        },

        //answer if a point is selected
        isSelected: function(x, y) {
            return this._isSelected(this.selections, x, y);
        },

        //answer if we have a selection covering a specific column
        isFixedRowCellSelected: function(col) {
            return this._isSelected(this.flattenedY, col, 0);
        },

        //answer if we have a selection covering a specific row
        isFixedColCellSelected: function(row) {
            return this._isSelected(this.flattenedX, 0, row);
        },

        //general selection query function
        _isSelected: function(selections, x, y) {
            for (var i = 0; i < selections.length; i++) {
                var each = selections[i];
                if (this.rectangles.rectangle.contains(each, x, y)) {
                    return true;
                }
            }
            return false;
        },

        //empty out all our state
        clear: function() {
            this.selections.length = 0;
            this.flattenedX.length = 0;
            this.flattenedY.length = 0;
        }

    });

})(); /* jslint ignore:line */

  </script>
</polymer-element>

<polymer-element name="fin-hypergrid-cell-editor-base" assetpath="cell-editors/">
  <template>
  </template>
  <script>

'use strict';

(function() {

    Polymer('fin-hypergrid-cell-editor-base',{ /* jshint ignore:line */

        isEditing: false,
        editorPoint: null,
        checkEditorPositionFlag: false,
        input: null,
        alias: 'base',
        grid: null,

        //Currently the only CellEditor is an input field.  The structure is in place for handling the CellEditor during focus change and grid scrolling.
        //TODO:Generalize the cell editing functionality to delegate through the behvior objects and then through the cell editors.  Add more general CellEditor types/drop down/button/calendar/spinner/etc...
        ready: function() {
            this.readyInit();
        },

        readyInit: function() {

        },

        installOn: function(grid) {
            this.grid = grid;
            grid.registerCellEditor(this.alias, this);
        },

        getBehavior: function() {
            return this.grid.getBehavior();
        },

        gridRenderedNotification: function() {
            this.checkEditor();
        },

        scrollValueChangedNotification: function() {
            this.setCheckEditorPositionFlag();
        },

        setCheckEditorPositionFlag: function() {
            this.checkEditorPositionFlag = true;
        },

        beginEditAt: function(point) {
            this.setEditorPoint(point);
            var model = this.getBehavior();
            var value = model.getValue(point.x, point.y);
            this.setEditorValue(value);
            this.isEditing = true;
            this.setCheckEditorPositionFlag();
            this.checkEditor();
        },

        setEditorValue: function(value) {

        },

        getEditorPoint: function() {
            return this.editorPoint;
        },

        setEditorPoint: function(point) {
            this.editorPoint = point;
        },

        showEditor: function() {
        },

        hideEditor: function() {
        },

        stopEditing: function() {
            if (!this.isEditing) {
                return;
            }
            this.saveEditorValue();
            this.isEditing = false;
            this.hideEditor();
        },

        saveEditorValue: function() {
            var point = this.getEditorPoint();
            var value = this.getEditorValue();
            this.getBehavior().setValue(point.x, point.y, value);
        },

        getEditorValue: function() {

        },

        takeFocus: function() {

        },

        moveEditor: function(model) {
            var model = this.getBehavior();
            var numFixedCols = model.getFixedColCount();
            var numFixedRows = model.getFixedRowCount();
            var vScroll = this.grid.getVScrollValue();
            var hScroll = this.grid.getHScrollValue();
            var editorPoint = this.getEditorPoint();
            var x = editorPoint.x + numFixedCols - hScroll;
            var y = editorPoint.y + numFixedRows - vScroll;
            var eb = this.grid.getBoundsOfCell(this.rectangles.point.create(x, y));
            var db = this.grid.getDataBounds();
            var cellBounds = eb.intersect(db);
            this.setBounds(cellBounds);
            this.takeFocus();
        },

        setBounds: function(rectangle) {

        },

        checkEditor: function() {
            if (!this.checkEditorPositionFlag) {
                return;
            } else {
                this.checkEditorPositionFlag = false;
            }
            if (!this.isEditing) {
                return;
            }
            var editorPoint = this.getEditorPoint();
            if (this.grid.isDataVisible(editorPoint.x, editorPoint.y)) {
                this.moveEditor();
                this.showEditor();
            } else {
                this.hideEditor();
            }
        }

    });

})(); /* jshint ignore:line */

  </script>
</polymer-element>
<polymer-element name="fin-hypergrid-cell-editor-simple" extends="fin-hypergrid-cell-editor-base" assetpath="cell-editors/">
  <template>
    <div id="editor"></div>
  </template>
  <script>

'use strict';

(function() {

    Polymer('fin-hypergrid-cell-editor-simple',{ /* jshint ignore:line */
        alias: 'simple',

        readyInit: function() {
            var self = this;
            this.rectangles = document.createElement('fin-rectangle');
            this.editorPoint = this.rectangles.point.create(0, 0);
            this.input = this.shadowRoot.querySelector('#editor');
            this.input.addEventListener('keypress', function(e) {
                if (e && e.keyCode === 13) {
                    e.preventDefault();
                    self.stopEditing();
                    self.grid.repaint();
                    self.grid.takeFocus();
                }
            });
            this.input.style.position = 'absolute';
            this.input.style.display = 'none';
            this.input.style.border = 'solid 2px black';
            this.input.style.outline = 0;
            this.input.style.padding = 0;
            this.input.style.zIndex = 1000;
        },

        getEditorValue: function() {
            var value = this.input.value;
            return value;
        },

        setEditorValue: function(value) {
            this.input.value = value + '';
        },

        showEditor: function() {
            this.input.style.display = 'inline';
        },

        hideEditor: function() {
            this.input.style.display = 'none';
        },

        takeFocus: function() {
            var self = this;
            setTimeout(function() {
                self.input.focus();
                self.selectAll();
            }, 300);
        },

        selectAll: function() {

        },

        setBounds: function(cellBounds) {
            var translation = 'translate(' + (cellBounds.origin.x - 2) + 'px,' + (cellBounds.origin.y - 2) + 'px)';
            this.input.style.webkitTransform = translation;
            this.input.style.MozTransform = translation;
            this.input.style.msTransform = translation;
            this.input.style.OTransform = translation;

            this.input.style.width = cellBounds.extent.x + 'px';
            this.input.style.height = cellBounds.extent.y + 'px';
        }

    });

})(); /* jshint ignore:line */

  </script>
</polymer-element>
<polymer-element name="fin-hypergrid-cell-editor-textfield" extends="fin-hypergrid-cell-editor-simple" assetpath="cell-editors/">
  <template>
    <input id="editor">
  </template>
  <script>

'use strict';

(function() {

    Polymer('fin-hypergrid-cell-editor-textfield',{ /* jshint ignore:line */
        alias: 'textfield',
        selectAll: function() {
            this.input.setSelectionRange(0, this.input.value.length);
        }
    });

})(); /* jshint ignore:line */

  </script>
</polymer-element>

<polymer-element name="fin-hypergrid-cell-editor-choice" extends="fin-hypergrid-cell-editor-simple" assetpath="cell-editors/">
  <template>
    <select id="editor">
        
            <option value="{{item}}">{{item}}</option>
        
    </select>
  </template>
  <script>

'use strict';

(function() {

    Polymer('fin-hypergrid-cell-editor-choice',{ /* jshint ignore:line */
        alias: 'choice',
        items:['Moe','Larry','Curly','Groucho','Harpo','Zeppo','Chico'],
    });

})(); /* jshint ignore:line */

  </script>
</polymer-element>

<polymer-element name="fin-hypergrid-cell-editor-color" extends="fin-hypergrid-cell-editor-simple" assetpath="cell-editors/">
  <template>
    <input id="editor" type="color">
  </template>
  <script>

'use strict';

(function() {

    Polymer('fin-hypergrid-cell-editor-color',{ /* jshint ignore:line */
        alias: 'color'
    });

})(); /* jshint ignore:line */

  </script>
</polymer-element>

<polymer-element name="fin-hypergrid-cell-editor-date" extends="fin-hypergrid-cell-editor-simple" assetpath="cell-editors/">
  <template>
    <input id="editor" type="date">
  </template>
  <script>

'use strict';

(function() {

    Polymer('fin-hypergrid-cell-editor-date',{ /* jshint ignore:line */
        alias: 'date'
    });

})(); /* jshint ignore:line */

  </script>
</polymer-element>

<polymer-element name="fin-hypergrid-cell-editor-slider" extends="fin-hypergrid-cell-editor-simple" assetpath="cell-editors/">
  <template>
    <input id="editor" type="range">
  </template>
  <script>

'use strict';

(function() {

    Polymer('fin-hypergrid-cell-editor-slider',{ /* jshint ignore:line */
        alias: 'slider'
    });

})(); /* jshint ignore:line */

  </script>
</polymer-element>

<polymer-element name="fin-hypergrid-cell-editor-spinner" extends="fin-hypergrid-cell-editor-simple" assetpath="cell-editors/">
  <template>
    <input id="editor" type="number">
  </template>
  <script>

'use strict';

(function() {

    Polymer('fin-hypergrid-cell-editor-spinner',{ /* jshint ignore:line */
        alias: 'spinner'
    });

})(); /* jshint ignore:line */

  </script>
</polymer-element>
<polymer-element name="fin-hypergrid" assetpath="">
  <template>
    <style>
    :host {
        position: relative;
        display: inline-block;
        webkit-user-select: none;
        moz-user-select: none;
        ms-user-select: none;
        o-user-select: none;
        user-select: none;
    }
    #verticalScroller {
        position: absolute;
        top: 0;
        right: 0;
        bottom: 0;
        left: 100%;
        margin-top: 0;
        margin-left: -15px;
        margin-bottom: 15px;
        margin-right: 15px;
    }
    #horizontalScroller {
        position: absolute;
        top: 100%;
        right: 0;
        bottom: 0;
        left: 0;
        margin-top: -15px;
        margin-left: 0;
        margin-bottom: 15px;
        margin-right: 15px;
    }
    #editor {
        position: absolute;
        display: none;
        border: solid 2px black;
        outline: 0;
        padding: 0;
        z-index: 1000;
    }
    </style>

    <fin-plugins>
        <fin-hypergrid-cell-editor-textfield></fin-hypergrid-cell-editor-textfield>
        <fin-hypergrid-cell-editor-choice></fin-hypergrid-cell-editor-choice>
        <fin-hypergrid-cell-editor-color></fin-hypergrid-cell-editor-color>
        <fin-hypergrid-cell-editor-date></fin-hypergrid-cell-editor-date>
        <fin-hypergrid-cell-editor-slider></fin-hypergrid-cell-editor-slider>
        <fin-hypergrid-cell-editor-spinner></fin-hypergrid-cell-editor-spinner>
        <fin-hypergrid-excel></fin-hypergrid-excel>
    </fin-plugins>

    <fin-canvas>
      <fin-hypergrid-renderer></fin-hypergrid-renderer>
    </fin-canvas>
    <fin-vampire-bar id="horizontalScroller" horizontal=""></fin-vampire-bar>
    <fin-vampire-bar id="verticalScroller"></fin-vampire-bar>
    <input id="editor">
    <content></content>
  </template>
  <script>

/* globals document, alert */

'use strict';

(function() {

    var noop = function() {};

    Polymer('fin-hypergrid',{ /* jslint ignore:line */

        /**                                                             .
         * behavior is a property of fin-hypergrid
         *
         * @property behavior
         * @type fin-hypergrid-behavior
         */
        behavior: {
            setScrollPositionY: noop,
            setScrollPositionX: noop,
            getColCount: noop,
            getFixedColCount: noop,
            getFixedColsWidth: noop,
            getFixedColsMaxWidth: noop,
            setRenderedWidth: noop,
            getRowCount: noop,
            getFixedRowCount: noop,
            getFixedRowsHeight: noop,
            getFixedRowsMaxHeight: noop,
            setRenderedHeight: noop,
            getCellProvider: noop,
            delegateClick: noop,
            delegateDoubleClick: noop
        },

        /**                                                             .
         * mouseDown is a property of fin-hypergrid
         *
         * @property mouseDown
         * @type boolean
         */
        mouseDown: null,

        /**                                                             .
         * dragExtent is a property of fin-hypergrid
         *
         * @property dragExtent
         * @type fin-rectangle.point
         */
        dragExtent: null,

        /**                                                             .
         * scrollingNow is a property of fin-hypergrid
         *
         * @property scrollingNow
         * @type boolean
         */
        scrollingNow: false,

        /**                                                             .
         * currentDrag is a property of fin-hypergrid
         *
         * @property currentDrag
         * @type fin-rectangle.point
         */
        currentDrag: null,

        /**                                                             .
         * lastDragCell is a property of fin-hypergrid
         *
         * @property lastDragCell
         * @type Object
         */
        lastDragCell: null,

        /**                                                             .
         * vScrollValue is a property of fin-hypergrid
         *
         * @property vScrollValue
         * @type Number
         */
        vScrollValue: 0,

        /**                                                             .
         * hScrollValue is a property of fin-hypergrid
         *
         * @property hScrollValue
         * @type Number
         */
        hScrollValue: 0,

        /**                                                             .
         * rectangles is a property of fin-hypergrid
         *
         * @property rectangles
         * @type fin-rectange
         */
        rectangles: null,

        /**                                                             .
         * constants is a property of fin-hypergrid
         *
         * @property constants
         * @type fin-hypergrid-constants
         */
        constants: null,

        /**                                                             .
         * selectionModel is a property of fin-hypergrid
         *
         * @property selectionModel
         * @type fin-hypergrid-selection-model
         */
        selectionModel: null,

        /**                                                             .
         * currentCellEditor is a property of fin-hypergrid
         *
         * @property currentCellEditor
         * @type fin-hypergrid-cell-editor
         */
        currentCellEditor: null,

        /**                                                             .
         * sbMouseIsDown is a property of fin-hypergrid
         *
         * @property sbMouseIsDown
         * @type boolean
         */
        sbMouseIsDown: false,

        /**                                                             .
         * sbHScroller is a property of fin-hypergrid
         *
         * @property sbHScroller
         * @type fin-vampire-bar
         */
        sbHScroller: null,

        /**                                                             .
         * sbVScroller is a property of fin-hypergrid
         *
         * @property sbVScroller
         * @type fin-vampire-bar
         */
        sbVScroller: null,

        /**                                                             .
         * sbHScrollConfig is a property of fin-hypergrid
         *
         * @property sbHScrollConfig
         * @type Object
         */
        sbHScrollConfig: {},

        /**                                                             .
         * sbVScrollConfig is a property of fin-hypergrid
         *
         * @property sbVScrollConfig
         * @type Object
         */
        sbVScrollConfig: {},

        /**                                                             .
         * sbLastAutoScroll is a property of fin-hypergrid
         *
         * @property sbLastAutoScroll
         * @type Number
         */
        sbLastAutoScroll: 0,

        /**                                                             .
         * sbAutoScrollStartTime is a property of fin-hypergrid
         *
         * @property sbAutoScrollStartTime
         * @type Number
         */
        sbAutoScrollStartTime: 0,

        /**                                                             .
         * sbPreviousVScrollValue is a property of fin-hypergrid
         *
         * @property sbPreviousVScrollValue
         * @type Number
         */
        sbPreviousVScrollValue: null,

        /**                                                             .
         * sbPreviousHScrollValue is a property of fin-hypergrid
         *
         * @property sbPreviousHScrollValue
         * @type Number
         */
        sbPreviousHScrollValue: null,

        /**                                                             .
         * sbHValueHolder is a property of fin-hypergrid
         *
         * @property sbHValueHolder
         * @type Object
         */

        sbHValueHolder: {},

        /**                                                             .
         * sbVValueHolder is a property of fin-hypergrid
         *
         * @property sbVValueHolder
         * @type Object
         */
        sbVValueHolder: {},

        /**                                                             .
         * cellEditors is a property of fin-hypergrid
         *
         * @property cellEditors
         * @type Object
         */
        cellEditors: null,

        domReady: function() {
            var self = this;

            this.cellEditors = {};

            //prevent the default context menu for appearing
            this.oncontextmenu = function(event) {
                event.preventDefault();
                return false;
            };

            this.rectangles = document.createElement('fin-rectangle');
            this.constants = document.createElement('fin-hypergrid-constants').values;
            this.selectionModel = document.createElement('fin-hypergrid-selection-model');
            //this.selectionModel.setGrid(this);

            //setup the model
            this.pluginsDo(function(each) {
                if (each.installOn) {
                    each.installOn(self);
                }
            });

            // var children = this.children;
            // console.log(children);

            this.mouseDown = this.rectangles.point.create(-1, -1);
            this.dragExtent = this.rectangles.point.create(0, 0);

            this.initCanvas();
            this.initRenderer();
            this.initScrollbars();

            //Register a listener for the copy event so we can copy our selected region to the pastebuffer if conditions are right.
            document.body.addEventListener('copy', function(evt) {
                self.checkClipboardCopy(evt);
            });
            this.resized();

        },

        pluginsDo: function(func) {
            var userPlugins = this.children.array();
            var pluginsTag = this.shadowRoot.querySelector('fin-plugins');

            var plugins = userPlugins;
            if (pluginsTag) {
                var systemPlugins = pluginsTag.children.array();
                plugins = systemPlugins.concat(plugins);
            }

            for (var i = 0; i < plugins.length; i++) {
                var plugin = plugins[i];
                func(plugin);
            }
        },

        //The CellProvider is accessed through Hypergrid because Hypergrid is the mediator and should have ultimate control on where it comes from.  The default is to delegate through the PluggableGridBehavior object.
        getCellProvider: function() {
            var provider = this.getBehavior().getCellProvider();
            return provider;
        },

        //This function is a callback from the HypergridRenderer sub-component.   It is called after each paint of the canvas.
        gridRenderedNotification: function() {
            this.updateRenderedSizes();
            this.pluginsDo(function(each) {
                if (each.gridRenderedNotification) {
                    each.gridRenderedNotification();
                }
            });
        },

        //Notify the PluggableGridBehavior how many rows and columns we just rendered.
        updateRenderedSizes: function() {
            var behavior = this.getBehavior();
            //add one to each of these values as we want also to include
            //the cols and rows that are partially visible
            behavior.setRenderedWidth(this.getViewableCols() + 1);
            behavior.setRenderedHeight(this.getViewableRows() + 1);
        },

        //If we have focus, copy our current selection data to the system clipboard.
        checkClipboardCopy: function(evt) {
            if (!this.hasFocus()) {
                return;
            }
            evt.preventDefault();
            var csvData = this.getSelectionAsTSV();
            evt.clipboardData.setData('text/plain', csvData);
        },

        hasSelections: function() {
            if (!this.getSelectionModel) {
                return; // were not fully initialized yet
            }
            return this.getSelectionModel().hasSelections();
        },

        //Return a tab seperated value string from the selection and our data.
        getSelectionAsTSV: function() {
            //only use the data from the last selection
            var selectionModel = this.getSelectionModel();
            var selections = selectionModel.getSelections();
            if (selections.length === 0) {
                return;
            }
            var last = selections[selections.length - 1];
            var area = last.area();
            //disallow if selection is too big
            if (area > 10000) {
                alert('selection size is too big to copy to the paste buffer');
                return '';
            }
            var behavior = this.getBehavior();
            var collector = [];
            var xstart = last.origin.x;
            var xstop = last.origin.x + last.extent.x + 1;
            var ystart = last.origin.y;
            var ystop = last.origin.y + last.extent.y + 1;
            for (var y = ystart; y < ystop; y++) {
                for (var x = xstart; x < xstop; x++) {
                    var data = behavior.getValue(x, y);
                    collector.push(data);
                    if (x !== xstop - 1) {
                        collector.push('\t');
                    }
                }
                if (y !== ystop - 1) {
                    collector.push('\n');
                }
            }
            var text = collector.join('');
            return text;
        },

        //Answer if we currently have focus
        hasFocus: function() {
            return this.getCanvas().hasFocus();
        },

        //Clear all the selections out
        clearSelections: function() {
            this.getSelectionModel().clear();
        },

        //Clear just the most recent selection
        clearMostRecentSelection: function() {
            this.getSelectionModel().clearMostRecentSelection();
        },

        //Select a specific region by origin and extent
        select: function(ox, oy, ex, ey) {
            this.getSelectionModel().select(ox, oy, ex, ey);
        },

        //Answer if a specific point is selected
        isSelected: function(x, y) {
            return this.getSelectionModel().isSelected(x, y);
        },

        //Answer if a specific col is selected anywhere in the entire table
        isFixedRowCellSelected: function(col) {
            var selectionModel = this.getSelectionModel();
            var isSelected = selectionModel.isFixedRowCellSelected(col);
            return isSelected;
        },

        //Answer if a specific row is selected anywhere in the entire table
        isFixedColCellSelected: function(row) {
            var selectionModel = this.getSelectionModel();
            var isSelected = selectionModel.isFixedColCellSelected(row);
            return isSelected;
        },

        getSelectionModel: function() {
            return this.selectionModel;
        },

        getMouseDown: function() {
            return this.mouseDown;
        },

        setMouseDown: function(point) {
            this.mouseDown = point;
        },

        getDragExtent: function() {
            return this.dragExtent;
        },

        setDragExtent: function(point) {
            this.dragExtent = point;
        },

        getBehavior: function() {
            return this.behavior;
        },

        //Set the PluggableBehavior object for this grid control.  This can be done dynamically and is how you configure the self.
        setBehavior: function(newBehavior) {

            this.behavior = newBehavior;
            this.behavior.setGrid(this);

            var self = this;

            var numCols = this.behavior.getColCount();
            var numRows = this.behavior.getRowCount();

            this.behavior.changed = function() {
                if (numCols !== self.behavior.getColCount() || numRows !== self.behavior.getRowCount()) {
                    numCols = self.behavior.getColCount();
                    numRows = self.behavior.getRowCount();
                    self.behaviorShapeChanged();
                }
                self.repaint();
            };

            this.behavior.sizeChanged = function() {
                self.repaint();
            };

            //this.detachRenderer();
            if (this.behavior) {
                //this.attachRenderer();
            }
        },

        behaviorShapeChanged: function() {
            this.synchronizeScrollingBoundries();
        },

        repaint: function() {
            this.getCanvas().repaint();
        },

        //Initialize the [OFCanvas](https://github.com/stevewirts/ofcanvas) component.
        initCanvas: function() {

            var self = this;
            var domCanvas = this.shadowRoot.querySelector('fin-canvas');

            domCanvas.setAttribute('fps', this.constants.repaintIntervalRate || 15);

            this.shadowRoot.appendChild(domCanvas);

            this.canvas = this.shadowRoot.querySelector('fin-canvas');

            this.canvas.style.position = 'absolute';
            this.canvas.style.top = 0;
            this.canvas.style.right = 0;
            //leave room for the vertical scrollbar
            this.canvas.style.marginRight = '15px';
            this.canvas.style.bottom = 0;
            //leave room for the horizontal scrollbar
            this.canvas.style.marginBottom = '15px';
            this.canvas.style.left = 0;

            this.canvas.resizeNotification = function() {
                self.resized();
            };

            this.canvas.addEventListener('fin-mousedown', function(e) {
                self.stopEditing();
                var mouse = e.detail.mouse;
                var cell = self.getCellFromMousePoint(mouse).cell;
                self.mouseDownHandler(cell, e.detail.keys);
            });

            this.canvas.addEventListener('fin-mouseup', function() {
                if (self.scrollingNow) {
                    self.scrollingNow = false;
                }
            });


            this.canvas.addEventListener('fin-drag', function(e) {
                var mouse = e.detail.mouse;
                var cell = self.getCellFromMousePoint(mouse).cell;
                self.currentDrag = mouse;
                self.lastDragCell = cell;
                self.checkDragScroll(e, cell);
                self.mouseDragHandler(cell, e.detail.keys);
            });

            this.canvas.addEventListener('fin-mouseup', function() {
                self.scrollingNow = false;
            });

            this.canvas.addEventListener('fin-keydown', function(e) {
                self.keydown(e);
            });

            this.canvas.addEventListener('fin-click', function(e) {
                var mouse = e.detail.mouse;
                var cell = self.getCellFromMousePoint(mouse);
                self.click(cell);
            });

            this.canvas.addEventListener('fin-dblclick', function(e) {
                var mouse = e.detail.mouse;
                var cell = self.getCellFromMousePoint(mouse);
                self.doubleclick(cell);
            });
        },

        stopEditing: function() {
            if (this.currentCellEditor) {
                this.currentCellEditor.stopEditing();
                this.currentCellEditor = null;
            }
        },

        registerCellEditor: function(alias, cellEditor) {
            this.cellEditors[alias] = cellEditor;
        },

        scrollDrag: function() {
            if (!this.scrollingNow) {
                return;
            }
            var b = this.getDataBounds();
            var xOffset = 0;
            var yOffset = 0;
            if (this.currentDrag.x < b.origin.x) {
                xOffset = -1;
            }
            if (this.currentDrag.x > b.origin.x + b.extent.x) {
                xOffset = 1;
            }
            if (this.currentDrag.y < b.origin.y) {
                yOffset = -1;
            }
            if (this.currentDrag.y > b.origin.y + b.extent.y) {
                yOffset = 1;
            }

            this.scrollBy(xOffset, yOffset);
            this.mouseDragHandler(this.lastDragCell, []); // update the selection
            this.repaint();

            setTimeout(this.scrollDrag.bind(this), 25);
        },

        checkDragScroll: function(e) {
            var mouse = e.detail.mouse;
            var b = this.getDataBounds();
            var inside = b.contains(mouse);
            if (inside) {
                if (this.scrollingNow) {
                    this.scrollingNow = false;
                }
            } else if (!this.scrollingNow) {
                this.scrollingNow = true;
                this.scrollDrag();
            }
        },

        getDataBounds: function() {
            var behavior = this.getBehavior();
            var b = this.canvas.bounds;

            var x = behavior.getFixedColsWidth() + 2;
            var y = behavior.getFixedRowsHeight() + 2;

            var result = this.rectangles.rectangle.create(x, y, b.origin.x + b.extent.x - x, b.origin.y + b.extent.y - y);
            return result;
        },

        getCanvas: function() {
            return this.canvas;
        },
        //Delegate the click event to the PluggableBehavior.  We don't want to assume anything about what that may mean if anything.
        click: function(mouse) {
            var behavior = this.getBehavior();
            behavior.delegateClick(this, mouse);
        },

        //Delegate the doubleclick event to the PluggableBehavior.  We don't want to assume anything about what that may mean if anything.
        doubleclick: function(mouse) {
            var behavior = this.getBehavior();
            behavior.delegateDoubleClick(this, mouse);
        },

        //Currently this is called by default from the PluggableBehavior, this piece needs to be reworked to re-delegate back through the PluggableBehavior to let it decide how to edit the cell.
        editAt: function(cellEditor, coordinates) {

            this.currentCellEditor = cellEditor;

            var cell = coordinates.cell;
            var behavior = this.getBehavior();
            var scrollTop = this.getVScrollValue();
            var scrollLeft = this.getHScrollValue();

            var numFixedCols = behavior.getFixedColCount();
            var numFixedRows = behavior.getFixedRowCount();

            var x = cell.x - numFixedCols + scrollLeft;
            var y = cell.y - numFixedRows + scrollTop;

            if (x < 0 || y < 0) {
                return;
            }

            var editPoint = this.rectangles.point.create(x, y);
            this.setMouseDown(editPoint);
            this.setDragExtent(this.rectangles.point.create(0, 0));
            cellEditor.beginEditAt(editPoint);
        },

        //Generate a function name and call it on self.  This should also be delegated through PluggableBehavior keeping the default implementation here though.
        keydown: function(e) {
            var command = 'handle' + e.detail.char;
            if (this[command]) {
                this[command].call(this, e.detail);
            }
        },

        //If we are holding down the same navigation key, accelerate the increment we scroll
        getAutoScrollAcceleration: function() {
            var count = 1;
            var elapsed = this.getAutoScrollDuration() / 2000;
            count = Math.max(1, Math.floor(elapsed * elapsed * elapsed * elapsed));
            return count;
        },

        handleDOWNSHIFT: function() {
            var count = this.getAutoScrollAcceleration();
            this.moveShiftSelect(0, count);
        },

        handleUPSHIFT: function() {
            var count = this.getAutoScrollAcceleration();
            this.moveShiftSelect(0, -count);
        },

        handleLEFTSHIFT: function() {
            this.moveShiftSelect(-1, 0);
        },

        handleRIGHTSHIFT: function() {
            this.moveShiftSelect(1, 0);
        },

        handleDOWN: function() {
            var count = this.getAutoScrollAcceleration();
            this.moveSingleSelect(0, count);
        },

        handleUP: function() {
            var count = this.getAutoScrollAcceleration();
            this.moveSingleSelect(0, -count);
        },

        handleLEFT: function() {
            this.moveSingleSelect(-1, 0);
        },

        handleRIGHT: function() {
            this.moveSingleSelect(1, 0);
        },

        //Answer if a specific col is fully visible
        isDataColVisible: function(c) {
            var isVisible = this.getRenderer().isColVisible(c);
            return isVisible;
        },

        //Answer if a specific row is fully visible
        isDataRowVisible: function(r) {
            var isVisible = this.getRenderer().isRowVisible(r);
            return isVisible;
        },

        //Answer if a specific cell (col,row) fully is visible
        isDataVisible: function(c, r) {
            var isVisible = this.isDataRowVisible(r) && this.isDataColVisible(c);
            return isVisible;
        },

        //Augment the most recent selection extent by (offsetX,offsetY) and scroll if necessary.
        moveShiftSelect: function(offsetX, offsetY) {
            var behavior = this.getBehavior();

            var maxCols = behavior.getColCount() - 1;
            var maxRows = behavior.getRowCount() - 1;

            var origin = this.getMouseDown();
            var extent = this.getDragExtent();

            var newX = extent.x + offsetX;
            var newY = extent.y + offsetY;

            newX = Math.min(maxCols - origin.x, Math.max(-origin.x, newX));
            newY = Math.min(maxRows - origin.y, Math.max(-origin.y, newY));

            this.clearMostRecentSelection();
            this.select(origin.x, origin.y, newX, newY);

            this.setDragExtent(this.rectangles.point.create(newX, newY));

            this.insureModelColIsViewable(newX + origin.x, offsetX);
            this.insureModelRowIsViewable(newY + origin.y, offsetY);
            this.repaint();

        },

        //Replace the most recent selection with a single cell selection that is moved (offsetX,offsetY) from the previous selection extent.
        moveSingleSelect: function(offsetX, offsetY) {
            var behavior = this.getBehavior();

            var maxCols = behavior.getColCount() - 1;
            var maxRows = behavior.getRowCount() - 1;

            var mouseCorner = this.getMouseDown().plus(this.getDragExtent());

            var newX = mouseCorner.x + offsetX;
            var newY = mouseCorner.y + offsetY;

            newX = Math.min(maxCols, Math.max(0, newX));
            newY = Math.min(maxRows, Math.max(0, newY));

            this.clearSelections();
            this.select(newX, newY, 0, 0);
            this.setMouseDown(this.rectangles.point.create(newX, newY));
            this.setDragExtent(this.rectangles.point.create(0, 0));

            this.insureModelColIsViewable(newX, offsetX);
            this.insureModelRowIsViewable(newY, offsetY);

            this.repaint();

        },

        //Offset indicates the direction we are moving
        insureModelColIsViewable: function(c, offsetX) {
            //-1 because we want only fully visible cols, don't include partially
            //viewable columns
            var viewableCols = this.getViewableCols() - 1;
            if (!this.isDataColVisible(c)) {
                //the scroll position is the leftmost column
                var newSX = offsetX < 0 ? c : c - viewableCols;
                this.setHScrollValue(newSX);
                this.pingAutoScroll();
            }
        },

        //Offset indicates the direction we are moving
        insureModelRowIsViewable: function(r, offsetY) {
            //-1 because we want only fully visible rows, don't include partially
            //viewable rows
            var viewableRows = this.getViewableRows() - 1;
            if (!this.isDataRowVisible(r)) {
                //the scroll position is the topmost row
                var newSY = offsetY < 0 ? r : r - viewableRows;
                this.setVScrollValue(newSY);
                this.pingAutoScroll();
            }
        },

        scrollBy: function(offsetX, offsetY) {
            this.scrollHBy(offsetX);
            this.scrollVBy(offsetY);
        },

        scrollVBy: function(offsetY) {
            var max = this.sbVScrollConfig.rangeStop;
            var oldValue = this.getVScrollValue();
            var newValue = Math.min(max, Math.max(0, oldValue + offsetY));
            if (newValue === oldValue) {
                return;
            }
            this.setVScrollValue(newValue);
        },

        scrollHBy: function(offsetX) {
            var max = this.sbHScrollConfig.rangeStop;
            var oldValue = this.getHScrollValue();
            var newValue = Math.min(max, Math.max(0, oldValue + offsetX));
            if (newValue === oldValue) {
                return;
            }
            this.setHScrollValue(newValue);
        },

        //Handle a mousedrag selection
        mouseDragHandler: function(mouse /* ,keys */ ) {

            var behavior = this.getBehavior();

            var scrollTop = this.getVScrollValue();
            var scrollLeft = this.getHScrollValue();

            var numFixedCols = behavior.getFixedColCount();
            var numFixedRows = behavior.getFixedRowCount();

            var x = mouse.x - numFixedCols;
            var y = mouse.y - numFixedRows;

            x = Math.max(0, x);
            y = Math.max(0, y);

            var previousDragExtent = this.getDragExtent();
            var mouseDown = this.getMouseDown();

            var newX = x + scrollLeft - mouseDown.x;
            var newY = y + scrollTop - mouseDown.y;

            if (previousDragExtent.x === newX && previousDragExtent.y === newY) {
                return;
            }

            this.clearMostRecentSelection();

            this.select(mouseDown.x, mouseDown.y, newX, newY);

            var newDragExtent = this.rectangles.point.create(newX, newY);
            this.setDragExtent(newDragExtent);

            this.repaint();
        },

        //Handle a mousedown event
        mouseDownHandler: function(mouse, keys) {

            var behavior = this.getBehavior();
            var hasCTRL = keys.indexOf('CTRL') !== -1;
            var hasSHIFT = keys.indexOf('SHIFT') !== -1;
            var scrollTop = this.getVScrollValue();
            var scrollLeft = this.getHScrollValue();

            var numFixedCols = behavior.getFixedColCount();
            var numFixedRows = behavior.getFixedRowCount();

            var mousePoint = this.getMouseDown();
            var x = mouse.x - numFixedCols;
            var y = mouse.y - numFixedRows;

            if (x < 0 || y < 0) {
                return;
            }

            if (!hasCTRL && !hasSHIFT) {
                this.clearSelections();
            }

            if (hasSHIFT) {
                this.clearMostRecentSelection();
                this.select(mousePoint.x, mousePoint.y, x + scrollLeft - mousePoint.x, y + scrollTop - mousePoint.y);
                this.setDragExtent(this.rectangles.point.create(x + scrollLeft - mousePoint.x, y + scrollTop - mousePoint.y));
            } else {
                this.select(x + scrollLeft, y + scrollTop, 0, 0);
                this.setMouseDown(this.rectangles.point.create(x + scrollLeft, y + scrollTop));
                this.setDragExtent(this.rectangles.point.create(0, 0));
            }
            this.repaint();
        },

        //Answer which data cell is under a pixel value mouse point
        getCellFromMousePoint: function(mouse) {
            var cell = this.getRenderer().getCellFromMousePoint(mouse);
            return cell;
        },

        //Answer pixel based bounds rectangle given a data cell point
        getBoundsOfCell: function(cell) {
            var bounds = this.getRenderer().getBoundsOfCell(cell);
            return bounds;
        },

        //This is called by the OFCanvas when a resize occurs
        resized: function() {
            this.synchronizeScrollingBoundries();
        },
        count: 0,
        setVScrollValue: function(y) {
            this.count = this.count + 1;
            var self = this;
            this.getBehavior().setScrollPositionY(y);
            this.vScrollValue = y;
            this.scrollValueChangedNotification();
            setTimeout(function() {
                self.sbVRangeAdapter.subjectChanged();
            });
        },

        getVScrollValue: function() {
            return this.vScrollValue;
        },

        setHScrollValue: function(x) {
            var self = this;
            this.getBehavior().setScrollPositionX(x);
            this.hScrollValue = x;
            this.scrollValueChangedNotification();
            setTimeout(function() {
                self.sbHRangeAdapter.subjectChanged();
            });
        },

        getHScrollValue: function() {
            return this.hScrollValue;
        },

        takeFocus: function() {
            if (this.isEditing()) {
                this.editorTakeFocus();
            }
            this.getCanvas().takeFocus();
        },

        editorTakeFocus: function() {
            if (this.currentCellEditor) {
                return this.currentCellEditor.takeFocus();
            }
        },

        isEditing: function() {
            if (this.currentCellEditor) {
                return this.currentCellEditor.isEditing;
            }
            return false;
        },

        initScrollbars: function() {

            var self = this;
            var canvas = this.getCanvas();

            var scrollbars = this.shadowRoot.querySelectorAll('fin-vampire-bar');
            this.sbHScroller = scrollbars[0];
            this.sbVScroller = scrollbars[1];

            this.addEventListener('mousedown', function() {
                this.sbMouseIsDown = true;
            });

            document.addEventListener('mouseup', function(e) {
                if (!this.sbMouseIsDown) {
                    return;
                }
                self.sbMouseIsDown = false;
                var origin = canvas.getOrigin();
                var point = self.rectangles.point.create(e.x - origin.x, e.y - origin.y);
                if (!canvas.bounds.contains(point)) {
                    //it's a mouseup on the scrollbars we need to retake focus
                    self.takeFocus();
                }
            });

            this.sbHValueHolder = {
                changed: false,
                getValue: function() {
                    return self.getHScrollValue();
                },
                setValue: function(v) {
                    self.setHScrollValue(v);
                }
            };

            this.sbVValueHolder = {
                changed: false,
                getValue: function() {
                    return self.getVScrollValue();
                },
                setValue: function(v) {
                    self.setVScrollValue(v);
                }
            };

            this.sbHScrollConfig = {
                step: 1,
                page: 40,
                rangeStart: 0,
                rangeStop: 0
            };

            this.sbVScrollConfig = {
                step: 1,
                page: 40,
                rangeStart: 0,
                rangeStop: 0
            };

            this.sbHRangeAdapter = this.sbHScroller.createRangeAdapter(this.sbHValueHolder, this.sbHScrollConfig);
            this.sbVRangeAdapter = this.sbHScroller.createRangeAdapter(this.sbVValueHolder, this.sbVScrollConfig);

            this.sbHScroller.setRangeAdapter(this.sbHRangeAdapter);
            this.sbVScroller.setRangeAdapter(this.sbVRangeAdapter);

        },
        //provide a way to notify scrollbars that the underlying data has changed
        //the real solution is to use an aspect adapter here

        scrollValueChangedNotification: function() {

            if (this.hScrollValue === this.sbPreviousHScrollValue && this.vScrollValue === this.sbPreviousVScrollValue) {
                return;
            }

            this.sbHValueHolder.changed = !this.sbHValueHolder.changed;
            this.sbVValueHolder.changed = !this.sbVValueHolder.changed;

            this.sbPreviousHScrollValue = this.hScrollValue;
            this.sbPreviousVScrollValue = this.vScrollValue;

            if (this.currentCellEditor) {
                this.currentCellEditor.scrollValueChangedNotification();
            }
        },

        setAutoScrollStartTime: function() {
            this.sbAutoScrollStartTime = Date.now();
        },

        pingAutoScroll: function() {
            var now = Date.now();
            if (now - this.sbLastAutoScroll > 500) {
                this.setAutoScrollStartTime();
            }
            this.sbLastAutoScroll = Date.now();
        },

        getAutoScrollDuration: function() {
            if (Date.now() - this.sbLastAutoScroll > 500) {
                return 0;
            }
            return Date.now() - this.sbAutoScrollStartTime;
        },

        setValue: function(x, y, value) {
            this.getBehavior().setValue(x, y, value);
            this.repaint();
        },
        synchronizeScrollingBoundries: function() {

            var behavior = this.getBehavior();
            if (!behavior) {
                return;
            }
            var numCols = behavior.getColCount();
            var numRows = behavior.getRowCount();
            var bounds = this.getCanvas().getBounds();
            var scrollableHeight = bounds.height() - behavior.getFixedRowsHeight();
            var scrollableWidth = bounds.width() - behavior.getFixedColsMaxWidth();

            var lastPageColCount = 0;
            var colsWidth = 0;
            for (; lastPageColCount < numCols; lastPageColCount++) {
                var eachWidth = behavior.getColWidth(numCols - lastPageColCount - 1);
                colsWidth = colsWidth + eachWidth;
                if (colsWidth > scrollableWidth) {
                    break;
                }
            }

            var lastPageRowCount = 0;
            var rowsHeight = 0;
            for (; lastPageRowCount < numRows; lastPageRowCount++) {
                var eachHeight = behavior.getRowHeight(numRows - lastPageRowCount - 1);
                rowsHeight = rowsHeight + eachHeight;
                if (rowsHeight > scrollableHeight) {
                    break;
                }
            }

            this.sbVScrollConfig.rangeStop = behavior.getRowCount() - lastPageRowCount;

            this.sbHScrollConfig.rangeStop = behavior.getColCount() - lastPageColCount;

            this.sbVScroller.tickle();
            this.sbHScroller.tickle();
        },

        //Answers the number of viewable rows, including any partially viewable rows.
        getViewableRows: function() {
            return this.getRenderer().getViewableRows();
        },

        //Answers the number of viewable cols, including any partially viewable cols.
        getViewableCols: function() {
            return this.getRenderer().getViewableCols();
        },

        //Initialize the GridRenderering sub-component.
        initRenderer: function() {

            this.renderer = this.shadowRoot.querySelector('fin-hypergrid-renderer');
            this.renderer.setGrid(this);
            // var props = {
            //     top: [0, 0],
            //     right: [1, 0],
            //     bottom: [1, 0],
            //     left: [0, 0]
            // };
            // this.renderer.setLayoutProperties(props);

        },
        getRenderer: function() {
            return this.renderer;
        },

        //Initialize the various pieces of the self.

    });

})(); /* jslint ignore:line */

  </script>
</polymer-element></div>
</body></html>