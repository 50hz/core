<!--

The `fin-hypergrid-feature-cell-selection` element is a custom Polymer web component that serves as the base "class" or API for the grid features (controllers).

@group OpenFin hypergrid
@element fin-hypergrid-feature-cell-selection
@homepage http://github.com/openfin/fin-hypergrid
-->

<polymer-element name="fin-hypergrid-feature-cell-selection" extends="fin-hypergrid-feature-base">
  <template></template>
  <script>


(function() {

'use strict';

    Polymer({ /* jshint ignore:line */

        /**
         * scrollingNow is true if we are scrolling now or false otherwise
         *
         * @property scrollingNow
         * @type boolean
         */
        scrollingNow: false,

        /**
         * currentDrag is the pixel location of the mouse pointer during a drag operation
         *
         * @property currentDrag
         * @type fin-rectangle.point
         */
        currentDrag: null,

        /**
         * lastDragCell is the cell coordinates of the where the mouse pointer is
         * during a drag operation
         *
         * @property lastDragCell
         * @type Object
         */
        lastDragCell: null,

        /**
         * answers if we are dragging right now
         *
         * @property dragging
         * @type Boolean
         */
        dragging: null,

        /**
         * sbLastAuto is a millisecond value representing the previous time an autoscroll started
         *
         * @property sbLastAuto
         * @type Number
         */
        sbLastAuto: 0,

        /**
         * sbAutoStart is a millisecond value representing the time the current autoscroll started
         *
         * @property sbAutoStart
         * @type Number
         */
        sbAutoStart: 0,

        rectangles: {},

        createdInit: function() {

            this.rectangles = document.createElement('fin-rectangle');
            this.dragging = false;

        },

        handleMouseDown: function(grid, event) {
            var gridCell = event.gridCell;
            if (gridCell.y < this.getFixedRowCount()) {
                this.clearSelections();
                return;
            } else if (gridCell.x < this.getFixedColCount()) {
                this.clearSelections();
                return;
            }
            else {
                var primEvent = event.primitiveEvent;
                var keys = primEvent.detail.keys;
                this.extendSelection(gridCell, keys);
            }
        },

        handleMouseDrag: function(grid, event) {
            var mouseDown = this.getMouseDown();
            if (mouseDown.x < 0 || mouseDown.y < 0) {
                //we are in the fixed area don't initiate a drag
                return;
            }
            var gridCell = event.gridCell;
            var primEvent = event.primitiveEvent;
            this.currentDrag = primEvent.detail.mouse;
            this.lastDragCell = gridCell;
            this.checkDragScroll(grid, this.currentDrag);
            this.handleMouseDragCellSelection(gridCell, primEvent.detail.keys);
        },

        handleKeyDown: function(grid, event) {
            var command = 'handle' + event.detail.char;
            if (this[command]) {
                this[command].call(this, event.detail);
            }
        },

        /**
         *                                                                      .
         *                                                                      .
         * Handle a mousedrag selection
         *
         * @method handleMouseDragCellSelection(mouse)
         */
        handleMouseDragCellSelection: function(mouse /* ,keys */ ) {

            var scrollTop = this.getVScrollValue();
            var scrollLeft = this.getHScrollValue();

            var numFixedCols = this.getFixedColCount();
            var numFixedRows = this.getFixedRowCount();

            var x = mouse.x - numFixedCols;
            var y = mouse.y - numFixedRows;

            x = Math.max(0, x);
            y = Math.max(0, y);

            var previousDragExtent = this.getDragExtent();
            var mouseDown = this.getMouseDown();

            var newX = x + scrollLeft - mouseDown.x;
            var newY = y + scrollTop - mouseDown.y;

            if (previousDragExtent.x === newX && previousDragExtent.y === newY) {
                return;
            }

            this.clearMostRecentSelection();

            this.select(mouseDown.x, mouseDown.y, newX, newY);

            var newDragExtent = this.rectangles.point.create(newX, newY);
            this.setDragExtent(newDragExtent);

            this.repaint();
        },

        /**
         *                                                                      .
         *                                                                      .
         * this checks while were dragging if we go outside the visible bounds,
         * if so, kick off the external autoscroll check function (above)
         *
         * @method checkDragScroll(event)
         */
        checkDragScroll: function(grid, mouse) {
            var b = grid.getDataBounds();
            var inside = b.contains(mouse);
            if (inside) {
                if (this.scrollingNow) {
                    this.scrollingNow = false;
                }
            } else if (!this.scrollingNow) {
                this.scrollingNow = true;
                this.scrollDrag(grid);
            }
        },

        /**
         *                                                                      .
         *                                                                      .
         * this function makes sure that while we are dragging outside of
         * the grid visible bounds, we srcroll accordingly
         *
         * @method scrollDrag()
         */
        scrollDrag: function(grid) {
            if (!this.scrollingNow) {
                return;
            }
            var b = this.getDataBounds();
            var xOffset = 0;
            var yOffset = 0;
            if (this.currentDrag.x < b.origin.x) {
                xOffset = -1;
            }
            if (this.currentDrag.x > b.origin.x + b.extent.x) {
                xOffset = 1;
            }
            if (this.currentDrag.y < b.origin.y) {
                yOffset = -1;
            }
            if (this.currentDrag.y > b.origin.y + b.extent.y) {
                yOffset = 1;
            }

            this.scrollBy(xOffset, yOffset);
            this.handleMouseDragCellSelection(this.lastDragCell, []); // update the selection
            this.repaint();

            setTimeout(this.scrollDrag.bind(this), 25);
        },

        clearSelections: function() {
            this.getBehavior().clearSelections();
            this.clearMouseDown();
        },

        /**
         *                                                                      .
         *                                                                      .
         * add a selection region
         *
         * @method select:(point)
         */
        select: function(ox, oy, ex, ey) {
            this.getBehavior().select(ox, oy, ex, ey);
        },

        /**
         *                                                                      .
         *                                                                      .
         * extend a selection or cteate one if there isnt yet
         *
         * @method extendSelection(mouse,keys)
         */
        extendSelection: function(gridCell, keys) {
            var behavior = this.getBehavior();
            var hasCTRL = keys.indexOf('CTRL') !== -1;
            var hasSHIFT = keys.indexOf('SHIFT') !== -1;
            var scrollTop = this.getVScrollValue();
            var scrollLeft = this.getHScrollValue();

            var numFixedCols = behavior.getFixedColCount();
            var numFixedRows = behavior.getFixedRowCount();

            var mousePoint = this.getMouseDown();
            var x = gridCell.x - numFixedCols + scrollLeft;
            var y = gridCell.y - numFixedRows + scrollTop;

            //were outside of the grid do nothing
            if (x < 0 || y < 0) {
                return;
            }

            //we have repeated a click in the same spot deslect the value from last time
            if (x === mousePoint.x && y === mousePoint.y) {
                this.clearMostRecentSelection();
                this.popMouseDown();
                this.repaint();
                return;
            }

            if (!hasCTRL && !hasSHIFT) {
                this.clearSelections();
            }

            if (hasSHIFT) {
                this.clearMostRecentSelection();
                this.select(mousePoint.x, mousePoint.y, x - mousePoint.x, y - mousePoint.y);
                this.setDragExtent(this.rectangles.point.create(x - mousePoint.x, y - mousePoint.y));
            } else {
                this.select(x, y, 0, 0);
                this.setMouseDown(this.rectangles.point.create(x, y));
                this.setDragExtent(this.rectangles.point.create(0, 0));
            }
            this.repaint();
        },
        clearMostRecentSelection: function() {
            this.getBehavior().clearMostRecentSelection();
        },

        /**
         *                                                                      .
         *                                                                      .
         * handle the shift down arrow key event
         *
         * @method handleDOWNSHIFT()
         */
        handleDOWNSHIFT: function() {
            var count = this.getAutoScrollAcceleration();
            this.moveShiftSelect(0, count);
        },

        /**
         *                                                                      .
         *                                                                      .
         * handle the shift up arrow key event
         *
         * @method handleUPSHIFT()
         */
        handleUPSHIFT: function() {
            var count = this.getAutoScrollAcceleration();
            this.moveShiftSelect(0, -count);
        },

        /**
         *                                                                      .
         *                                                                      .
         * handle the shift left arrow key event
         *
         * @method handleLEFTSHIFT()
         */
        handleLEFTSHIFT: function() {
            this.moveShiftSelect(-1, 0);
        },

        /**
         *                                                                      .
         *                                                                      .
         * handle the shift right arrow key event
         *
         * @method handleRIGHTSHIFT()
         */
        handleRIGHTSHIFT: function() {
            this.moveShiftSelect(1, 0);
        },

        /**
         *                                                                      .
         *                                                                      .
         * handle the down arrow key event
         *
         * @method handleDOWN()
         */
        handleDOWN: function() {
            var count = this.getAutoScrollAcceleration();
            this.moveSingleSelect(0, count);
        },

        /**
         *                                                                      .
         *                                                                      .
         * handle the up arrow key event
         *
         * @method handleUP()
         */
        handleUP: function() {
            var count = this.getAutoScrollAcceleration();
            this.moveSingleSelect(0, -count);
        },

        /**
         *                                                                      .
         *                                                                      .
         * handle the left arrow key event
         *
         * @method handleLEFT()
         */
        handleLEFT: function() {
            this.moveSingleSelect(-1, 0);
        },

        /**
         *                                                                      .
         *                                                                      .
         * handle the right arrow key event
         *
         * @method handleRIGHT()
         */
        handleRIGHT: function() {
            this.moveSingleSelect(1, 0);
        },

        /**
         *                                                                      .
         *                                                                      .
         * If we are holding down the same navigation key, accelerate the increment we scroll
         *
         * @method getAutoScrollAcceleration()
         */
        getAutoScrollAcceleration: function() {
            var count = 1;
            var elapsed = this.getAutoScrollDuration() / 2000;
            count = Math.max(1, Math.floor(elapsed * elapsed * elapsed * elapsed));
            return count;
        },

        /**
         *                                                                      .
         *                                                                      .
         * set the start time when we initiated an auto scroll
         *
         * @method setAutoScrollStartTime()
         */
        setAutoScrollStartTime: function() {
            this.sbAutoStart = Date.now();
        },

        /**
         *                                                                      .
         *                                                                      .
         * update the autoscroll start time if we haven't autoscrolled within the last 500ms
         * otherwise update the current autoscroll time
         *
         * @method pingAutoScroll()
         */
        pingAutoScroll: function() {
            var now = Date.now();
            if (now - this.sbLastAuto > 500) {
                this.setAutoScrollStartTime();
            }
            this.sbLastAuto = Date.now();
        },

        /**
         *                                                                      .
         *                                                                      .
         * answer how long we have been auto scrolling
         *
         * @method getAutoScrollDuration()
         */
        getAutoScrollDuration: function() {
            if (Date.now() - this.sbLastAuto > 500) {
                return 0;
            }
            return Date.now() - this.sbAutoStart;
        },

        /**
         *                                                                      .
         *                                                                      .
         * Augment the most recent selection extent by (offsetX,offsetY) and scroll if necessary.
         *
         * @method moveShiftSelect(offsetX,offsetY)
         */
        moveShiftSelect: function(offsetX, offsetY) {
            var behavior = this.getBehavior();

            var maxCols = behavior.getColCount() - 1;
            var maxRows = behavior.getRowCount() - 1;

            var origin = this.getMouseDown();
            var extent = this.getDragExtent();

            var newX = extent.x + offsetX;
            var newY = extent.y + offsetY;

            newX = Math.min(maxCols - origin.x, Math.max(-origin.x, newX));
            newY = Math.min(maxRows - origin.y, Math.max(-origin.y, newY));

            this.clearMostRecentSelection();
            this.select(origin.x, origin.y, newX, newY);

            this.setDragExtent(this.rectangles.point.create(newX, newY));

            if (this.insureModelColIsViewable(newX + origin.x, offsetX)) {
                this.pingAutoScroll();
            }
            if (this.insureModelRowIsViewable(newY + origin.y, offsetY)) {
                this.pingAutoScroll();
            }

            this.repaint();

        },

        /**
         *                                                                      .
         *                                                                      .
         * Replace the most recent selection with a single cell selection that is moved (offsetX,offsetY) from the previous selection extent.
         *
         * @method moveSingleSelect(offsetX,offsetY)
         */
        moveSingleSelect: function(offsetX, offsetY) {

            var maxCols = this.getColCount() - 1;
            var maxRows = this.getRowCount() - 1;

            var mouseCorner = this.getMouseDown().plus(this.getDragExtent());

            var newX = mouseCorner.x + offsetX;
            var newY = mouseCorner.y + offsetY;

            newX = Math.min(maxCols, Math.max(0, newX));
            newY = Math.min(maxRows, Math.max(0, newY));

            this.clearSelections();
            this.select(newX, newY, 0, 0);
            this.setMouseDown(this.rectangles.point.create(newX, newY));
            this.setDragExtent(this.rectangles.point.create(0, 0));

            if (this.insureModelColIsViewable(newX, offsetX)) {
                this.pingAutoScroll();
            }
            if (this.insureModelRowIsViewable(newY, offsetY)) {
                this.pingAutoScroll();
            }

            this.repaint();

        }


    });
})(); /* jshint ignore:line */

  </script>
</polymer-element>
