<!--

The `fin-hypergrid-behavior-json` element is a custom Polymer web component used to support the openfin [fin-hypergrid](http://github.com/openfin/fin-hypergrid) component.

@group OpenFin hypergrid
@element fin-hypergrid-behavior-json
@homepage http://github.com/openfin/fin-hypergrid
-->

<link rel="import" href="fin-hypergrid-cell-provider.html">
<link rel="import" href="fin-hypergrid-behavior-default.html">
<polymer-element name="fin-hypergrid-behavior-json" extends="fin-hypergrid-behavior-default">
  <template></template>
  <script>

/*jshint  bitwise: false */
'use strict';

var quickSort = function(arr, key) {

  // return if array is unsortable
  if (arr.length <= 1){
    return arr;
  }

  var less = Array(), greater = Array();

  // select and remove a pivot value pivot from array
  // a pivot value closer to median of the dataset may result in better performance
  var pivotIndex = Math.floor(arr.length / 2);
  var pivot = arr.splice(pivotIndex, 1)[0];

  // step through all array elements
  for (var x = 0; x < arr.length; x++){

    // if (current value is less than pivot),
    // OR if (current value is the same as pivot AND this index is less than the index of the pivot in the original array)
    // then push onto end of less array
    if (
      (
        !key  // no object property name passed
        &&
        (
          (arr[x] < pivot)
          ||
          (arr[x] == pivot && x < pivotIndex)  // this maintains the original order of values equal to the pivot
        )
      )
      ||
      (
        key  // object property name passed
        &&
        (
          (arr[x][key] < pivot[key])
          ||
          (arr[x][key] == pivot[key] && x < pivotIndex)  // this maintains the original order of values equal to the pivot
        )
      )
    ){
      less.push(arr[x]);
    }

    // if (current value is greater than pivot),
    // OR if (current value is the same as pivot AND this index is greater than or equal to the index of the pivot in the original array)
    // then push onto end of greater array
    else {
      greater.push(arr[x]);
    }
  }

  // concatenate less+pivot+greater arrays
  return quickSort(less, key).concat([pivot], quickSort(greater, key));
};

 var names = ['Olivia', 'Sophia', 'Ava', 'Isabella', 'Boy', 'Liam', 'Noah', 'Ethan', 'Mason', 'Logan', 'Moe', 'Larry', 'Curly', 'Shemp', 'Groucho', 'Harpo', 'Chico', 'Zeppo', 'Stanely', 'Hardy'];
 var months = ['01', '02', '03', '04', '05', '06', '07', '08', '09', '10', '11', '12'];
 var days = ['01', '02', '03', '04', '05', '06', '07', '08', '09', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '20', '21', '22', '23', '24', '25', '26', '27', '28', '29', '30'];

var randomPerson = function() {
    var name = Math.round((names.length - 1) * Math.random());
    var pets = Math.round(10 * Math.random());
    var birthyear = 1900 + Math.round(Math.random() * 113);
    var birthmonth = Math.round(Math.random() * 11);
    var birthday = Math.round(Math.random() * 29);
    var score = Math.random() * 1000;
    var person = {
        name: names[name],
        pets: pets,
        birthdate: birthyear + '-' + months[birthmonth] + '-' + days[birthday],
        score: score
    };
    return person;
};


(function() {

    var headers =
        [
            'name',
            'pets',
            'birthdate',
            'score'
        ];

    var data = [];
    for (var i = 0; i < 20; i ++) {
        data.push(randomPerson());
    }

    Polymer({ /* jslint ignore:line */

        sorted: {},
        sortStates: [' ', ' ^', ' v'],
        data: data,
        headers: headers,

        getValue: function(x, y) {
            return this.data[y][this.headers[x]];
        },

        getFixedColValue: function(x, y) {
            return y;
        },

        getFixedRowValue: function(x, y) {
            var sortIndex = this.sorted[x] || 0;
            return this.headers[x] + this.sortStates[sortIndex];
        },

        getFixedColCount: function() {
            return 0;
        },

        getRowCount: function() {
            return this.data.length;
        },

        getColCount: function() {
            return this.headers.length;
        },

        fixedRowClicked: function(grid, mouse) {
            var colIndex = this.scrollPositionX + mouse.cell.x - this.getFixedColCount();
            this.toggleSort(colIndex);
        },

        toggleSort: function(colIndex) {
            if (colIndex >= this.headers.length) {
                return;
            }
            var current = this.sorted[colIndex] || 0;
            var stateCount = this.sortStates.length;
            var sortStateIndex = (current + 1) % stateCount;

            for (var i = 0; i < this.headers.length; i++) {
                this.sorted[i] = 0;
            }

            this.sorted[colIndex] = sortStateIndex;


            var colName = this.headers[colIndex];
            if (sortStateIndex === 0) {

            } else if (sortStateIndex === 1) {
                this.data = quickSort(this.data, colName);
            } else {
                this.data = this.data.reverse();
            }
            this.changed();
        }

    });

})(); /* jslint ignore:line */

  </script>
</polymer-element>
